//usr/bin/env node "$0" $@ ; exit $?
// Generated by CoffeeScript 1.6.3
(function() {
  var ADVERB, APLArray, Beta, CONJUNCTION, Complex, DYA, EMB, GET, JEQ, LAM, LDC, MON, NOUN, POP, RET, SET, SPL, VEC, VERB, addVocabulary, adverb, aka, all, apl, aplError, aplify, approx, arrayEquals, bool, compileAST, complexify, compressOrReplicate, conjunction, contains, cps, deal, depthOf, domainError, enlist, eq, exec, exp, expand, extend, first, format, getAxisList, grade, indexAtSingleAxis, indexError, innerProduct, lengthError, lnΓ, match, negInt, nonceError, numApprox, numeric, outerProduct, parse, pervasive, prelude, prod, rankError, reduce, repeat, repr, roll, rotate, scan, simplify, smallFactorials, squish, strideForShape, syntaxError, take, tokenDefs, tokenize, valueError, vm, vocabulary, withIdentity, Γ, λ, _base, _ref, _ref1, _ref2,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };



  prod = function(xs) {
    var r, x, _i, _len;
    r = 1;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      r *= x;
    }
    return r;
  };
  all = function(xs) {
    var x, _i, _len;
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (!x) {
        return false;
      }
    }
    return true;
  };
  repeat = function(a, n) {
    var m, tmp0;
    if (!(typeof a === 'string' || a instanceof Array)) {
      throw Error("\"assert typeof a is 'string' or a instanceof Array\" at src/helpers.coffee:20");
    }
    if (!((tmp0 = (n)) === ~~tmp0 && (0) <= tmp0)) {
      throw Error("\"assert isInt n, 0\" at src/helpers.coffee:21");
    }
    if (!n) {
      return a.slice(0, 0);
    }
    m = n * a.length;
    while (a.length * 2 < m) {
      a = a.concat(a);
    }
    return a.concat(a.slice(0, m - a.length));
  };
  extend = function(x, y) {
    var k;
    for (k in y) {
      x[k] = y[k];
    }
    return x;
  };
  if (this.Uint8Array == null) {
    this.Uint8Array = Array;
  }
  if (this.Uint16Array == null) {
    this.Uint16Array = Array;
  }
  if (this.Uint32Array == null) {
    this.Uint32Array = Array;
  }
  if (this.Int8Array == null) {
    this.Int8Array = Array;
  }
  if (this.Int16Array == null) {
    this.Int16Array = Array;
  }
  if (this.Int32Array == null) {
    this.Int32Array = Array;
  }
  if ((_base = Array.prototype).set == null) {
    _base.set = function(a, offset) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = a.length; _i < _ref; i = _i += 1) {
        this[offset + i] = a[i];
      }
    };
  }
  arrayEquals = function(a, b) {
    var i, x, _i, _len;
    if (!(a instanceof Array)) {
      throw Error("\"assert a instanceof Array\" at src/helpers.coffee:72");
    }
    if (!(b instanceof Array)) {
      throw Error("\"assert b instanceof Array\" at src/helpers.coffee:73");
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      x = a[i];
      if (x !== b[i]) {
        return false;
      }
    }
    return true;
  };

  aplError = function(name, message, opts) {
    var e, k, v, _ref;
    if (message == null) {
      message = '';
    }
    if (!(typeof name === 'string')) {
      throw Error("\"assert typeof name is 'string'\" at src/errors.coffee:2");
    }
    if (!(typeof message === 'string')) {
      throw Error("\"assert typeof message is 'string'\" at src/errors.coffee:3");
    }
    if (opts != null) {
      if (!(typeof opts === 'object')) {
        throw Error("\"assert typeof opts is 'object'\" at src/errors.coffee:5");
      }
      if ((opts.aplCode != null) && (opts.line != null) && (opts.col != null)) {
        if (!(typeof opts.aplCode === 'string')) {
          throw Error("\"assert typeof opts.aplCode is 'string'\" at src/errors.coffee:7");
        }
        if (!(typeof opts.line === 'number')) {
          throw Error("\"assert typeof opts.line is 'number'\" at src/errors.coffee:8");
        }
        if (!(typeof opts.col === 'number')) {
          throw Error("\"assert typeof opts.col is 'number'\" at src/errors.coffee:9");
        }
        if (!((_ref = typeof opts.file) === 'string' || _ref === 'undefined')) {
          throw Error("\"assert typeof opts.file in ['string', 'undefined']\" at src/errors.coffee:10");
        }
        message += "\n" + (opts.file || '-') + ":#" + opts.line + ":" + opts.col + "\n" + (opts.aplCode.split('\n')[opts.line - 1]) + "\n" + (repeat('_', opts.col - 1)) + "^";
      }
    }
    e = Error(message);
    e.name = name;
    for (k in opts) {
      v = opts[k];
      e[k] = v;
    }
    throw e;
  };
  syntaxError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['SYNTAX ERROR'].concat(__slice.call(a)));
  };
  domainError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['DOMAIN ERROR'].concat(__slice.call(a)));
  };
  lengthError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['LENGTH ERROR'].concat(__slice.call(a)));
  };
  rankError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['RANK ERROR'].concat(__slice.call(a)));
  };
  indexError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['INDEX ERROR'].concat(__slice.call(a)));
  };
  nonceError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['NONCE ERROR'].concat(__slice.call(a)));
  };
  valueError = function() {
    var a;
    a = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return aplError.apply(null, ['VALUE ERROR'].concat(__slice.call(a)));
  };

  APLArray = (function() {
    function APLArray(data, shape, stride, offset) {
      var i, tmp1, tmp2, tmp3, x, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      this.data = data;
      this.shape = shape;
      this.stride = stride;
      this.offset = offset != null ? offset : 0;
      if (this.shape == null) {
        this.shape = [this.data.length];
      }
      if (this.stride == null) {
        this.stride = strideForShape(this.shape);
      }
      if (!(this.data.length != null)) {
        throw Error("\"assert @data.length?\" at src/array.coffee:97");
      }
      if (!(this.shape instanceof Array)) {
        throw Error("\"assert @shape instanceof Array\" at src/array.coffee:98");
      }
      if (!(this.stride instanceof Array)) {
        throw Error("\"assert @stride instanceof Array\" at src/array.coffee:99");
      }
      if (!(this.data.length === 0 || ((tmp1 = this.offset) === ~~tmp1 && ((0) <= (_ref = tmp1) && _ref < this.data.length)))) {
        throw Error("\"assert @data.length is 0 or isInt @offset, 0, @data.length\" at src/array.coffee:100");
      }
      if (!(this.stride.length === this.shape.length)) {
        throw Error("\"assert @stride.length is ⍴⍴ @\" at src/array.coffee:101");
      }
      _ref1 = this.shape;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        x = _ref1[_i];
        if (!((tmp2 = (x)) === ~~tmp2 && (0) <= tmp2)) {
          throw Error("\"for x in @shape then assert isInt x, 0\" at src/array.coffee:102");
        }
      }
      if (this.data.length) {
        _ref2 = this.stride;
        for (i = _j = 0, _len1 = _ref2.length; _j < _len1; i = ++_j) {
          x = _ref2[i];
          if (!((tmp3 = (x)) === ~~tmp3 && ((-this.data.length) <= (_ref3 = tmp3) && _ref3 < (this.data.length + 1)))) {
            throw Error("\"for x, i in @stride then assert isInt x, -@data.length, @data.length + 1\" at src/array.coffee:104");
          }
        }
      }
    }

    APLArray.prototype.empty = function() {
      var d, _i, _len, _ref;
      _ref = this.shape;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        d = _ref[_i];
        if (!d) {
          return true;
        }
      }
      return false;
    };

    APLArray.prototype.map = function(f) {
      var data, indices, t10, t4, t5, t6, t7, t8, t9, x;
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/array.coffee:111");
      }
      data = [];
      t4 = this;
      if (!t4.empty()) {
        t6 = t4.data;
        t7 = t4.shape;
        t8 = t4.stride;
        t9 = t7.length - 1;
        t10 = t4.offset;
        indices = [];
        t5 = t7.length;
        while (--t5 >= 0) {
          indices.push(0);
        }
        while (true) {
          x = t6[t10];
          data.push(f(x, indices));
          t5 = t9;
          while (t5 >= 0 && indices[t5] + 1 === t7[t5]) {
            t10 -= indices[t5] * t8[t5];
            indices[t5--] = 0;
          }
          if (t5 < 0) {
            break;
          }
          indices[t5]++;
          t10 += t8[t5];
        }
      }
      return new APLArray(data, this.shape);
    };

    APLArray.prototype.map2 = function(a, f) {
      var data, indices, t11, t12, t13, t14, t15, t16, t17, t18, t19, t20, t21, t22, x, y;
      if (!(a instanceof APLArray)) {
        throw Error("\"assert a instanceof APLArray\" at src/array.coffee:117");
      }
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/array.coffee:118");
      }
      data = [];
      t11 = this;
      t16 = t11.data;
      t18 = t11.shape;
      t20 = t11.stride;
      t12 = a;
      t17 = t12.data;
      t19 = t12.shape;
      t21 = t12.stride;
      if (t18.length !== t19.length) {
        rankError();
      }
      t15 = t18.length;
      while (--t15 >= 0) {
        if (t18[t15] !== t19[t15]) {
          lengthError();
        }
      }
      if (!t11.empty()) {
        t22 = t18.length - 1;
        t13 = t11.offset;
        t14 = t12.offset;
        indices = Array((t15 = t18.length));
        while (--t15 >= 0) {
          indices[t15] = 0;
        }
        while (true) {
          x = t16[t13];
          y = t17[t14];
          data.push(f(x, y, indices));
          t15 = t22;
          while (t15 >= 0 && indices[t15] + 1 === t18[t15]) {
            t13 -= indices[t15] * t20[t15];
            t14 -= indices[t15] * t21[t15];
            indices[t15--] = 0;
          }
          if (t15 < 0) {
            break;
          }
          indices[t15]++;
          t13 += t20[t15];
          t14 += t21[t15];
        }
      }
      return new APLArray(data, this.shape);
    };

    APLArray.prototype.toArray = function() {
      var r, t23, t24, t25, t26, t27, t28, t29, t30, x;
      r = [];
      t23 = this;
      if (!t23.empty()) {
        t25 = t23.data;
        t26 = t23.shape;
        t27 = t23.stride;
        t28 = t26.length - 1;
        t30 = t23.offset;
        t29 = [];
        t24 = t26.length;
        while (--t24 >= 0) {
          t29.push(0);
        }
        while (true) {
          x = t25[t30];
          r.push(x);
          t24 = t28;
          while (t24 >= 0 && t29[t24] + 1 === t26[t24]) {
            t30 -= t29[t24] * t27[t24];
            t29[t24--] = 0;
          }
          if (t24 < 0) {
            break;
          }
          t29[t24]++;
          t30 += t27[t24];
        }
      }
      return r;
    };

    APLArray.prototype.toInt = function(start, end) {
      var r;
      if (start == null) {
        start = -Infinity;
      }
      if (end == null) {
        end = Infinity;
      }
      r = this.unwrap();
      if (typeof r !== 'number' || r !== ~~r || !((start <= r && r < end))) {
        return domainError();
      } else {
        return r;
      }
    };

    APLArray.prototype.toBool = function() {
      return this.toInt(0, 2);
    };

    APLArray.prototype.toSimpleString = function() {
      var a, x, _i, _len;
      if (this.shape.length > 1) {
        rankError();
      }
      if (typeof this.data === 'string') {
        if (!this.shape.length) {
          return this.data[this.offset];
        }
        if (this.shape[0] === 0) {
          return '';
        }
        if (this.stride[0] === 1) {
          return this.data.slice(this.offset, this.offset + this.shape[0]);
        }
        return this.toArray().join('');
      } else {
        a = this.toArray();
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          x = a[_i];
          if (typeof x !== 'string') {
            domainError();
          }
        }
        return a.join('');
      }
    };

    APLArray.prototype.isSingleton = function() {
      var n, _i, _len, _ref;
      _ref = this.shape;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (n !== 1) {
          return false;
        }
      }
      return true;
    };

    APLArray.prototype.isSimple = function() {
      return this.shape.length === 0 && !(this.data[this.offset] instanceof APLArray);
    };

    APLArray.prototype.unwrap = function() {
      if (prod(this.shape) === 1) {
        return this.data[this.offset];
      } else {
        return lengthError();
      }
    };

    APLArray.prototype.getPrototype = function() {
      if (this.empty() || typeof this.data[this.offset] !== 'string') {
        return 0;
      } else {
        return ' ';
      }
    };

    APLArray.prototype.toString = function() {
      return format(this).join('\n');
    };

    APLArray.prototype.repr = function() {
      return "new APLArray(" + (repr(this.data)) + "," + (repr(this.shape)) + "," + (repr(this.stride)) + "," + (repr(this.offset)) + ")";
    };

    return APLArray;

  })();
  strideForShape = function(shape) {
    var i, r, tmp31, _i, _ref;
    if (!(shape instanceof Array)) {
      throw Error("\"assert shape instanceof Array\" at src/array.coffee:157");
    }
    if (shape.length === 0) {
      return [];
    }
    r = Array(shape.length);
    r[r.length - 1] = 1;
    for (i = _i = _ref = r.length - 2; _i >= 0; i = _i += -1) {
      if (!((tmp31 = shape[i]) === ~~tmp31 && (0) <= tmp31)) {
        throw Error("\"assert isInt shape[i], 0\" at src/array.coffee:162");
      }
      r[i] = r[i + 1] * shape[i + 1];
    }
    return r;
  };
  APLArray.zero = new APLArray([0], []);
  APLArray.one = new APLArray([1], []);
  APLArray.zilde = new APLArray([], [0]);
  APLArray.scalar = function(x) {
    return new APLArray([x], []);
  };
  APLArray.bool = [APLArray.zero, APLArray.one];

  complexify = function(x) {
    if (typeof x === 'number') {
      return new Complex(x, 0);
    } else if (x instanceof Complex) {
      return x;
    } else {
      return domainError();
    }
  };
  simplify = function(re, im) {
    if (im !== 0) {
      return new Complex(re, im);
    } else {
      return re;
    }
  };
  Complex = (function() {
    var acos, add, asin, atan, cosh, direction, divide, exp, firstquadrant, floor, gcd, iszero, itimes, log, multiply, negate, negitimes, pow, residue, sinh, sqrt, subtract, tanh;

    function Complex(re, im) {
      this.re = re;
      this.im = im != null ? im : 0;
      if (!(typeof this.re === 'number')) {
        throw Error("\"assert typeof @re is 'number'\" at src/complex.coffee:20");
      }
      if (!(typeof this.im === 'number')) {
        throw Error("\"assert typeof @im is 'number'\" at src/complex.coffee:21");
      }
      if (isNaN(this.re) || isNaN(this.im)) {
        domainError('NaN');
      }
    }

    Complex.prototype.toString = function() {
      return "" + (('' + this.re).replace('Infinity', '∞').replace(/-/g, '¯')) + "J" + (('' + this.im).replace('Infinity', '∞').replace(/-/g, '¯'));
    };

    Complex.prototype.repr = function() {
      return "new Complex(" + (repr(this.re)) + "," + (repr(this.im)) + ")";
    };

    Complex.exp = exp = function(x) {
      var r;
      x = complexify(x);
      r = Math.exp(x.re);
      return simplify(r * Math.cos(x.im), r * Math.sin(x.im));
    };

    Complex.log = log = function(x) {
      if (typeof x === 'number' && x > 0) {
        return Math.log(x);
      } else {
        x = complexify(x);
        return simplify(Math.log(Math.sqrt(x.re * x.re + x.im * x.im)), direction(x));
      }
    };

    Complex.conjugate = function(x) {
      return new Complex(x.re, -x.im);
    };

    Complex.negate = negate = function(x) {
      return new Complex(-x.re, -x.im);
    };

    Complex.itimes = itimes = function(x) {
      x = complexify(x);
      return simplify(-x.im, x.re);
    };

    Complex.negitimes = negitimes = function(x) {
      x = complexify(x);
      return simplify(x.im, -x.re);
    };

    Complex.add = add = function(x, y) {
      x = complexify(x);
      y = complexify(y);
      return simplify(x.re + y.re, x.im + y.im);
    };

    Complex.subtract = subtract = function(x, y) {
      x = complexify(x);
      y = complexify(y);
      return simplify(x.re - y.re, x.im - y.im);
    };

    Complex.multiply = multiply = function(x, y) {
      x = complexify(x);
      y = complexify(y);
      return simplify(x.re * y.re - x.im * y.im, x.re * y.im + x.im * y.re);
    };

    Complex.divide = divide = function(x, y) {
      var d;
      x = complexify(x);
      y = complexify(y);
      d = y.re * y.re + y.im * y.im;
      return simplify((x.re * y.re + x.im * y.im) / d, (y.re * x.im - y.im * x.re) / d);
    };

    Complex.pow = pow = function(x, y) {
      var _ref;
      if ((typeof x === (_ref = typeof y) && _ref === 'number') && x >= 0) {
        return Math.pow(x, y);
      } else {
        return exp(multiply(y, log(x)));
      }
    };

    Complex.sqrt = sqrt = function(x) {
      if (typeof x === 'number' && x >= 0) {
        return Math.sqrt(x);
      } else {
        return pow(x, 0.5);
      }
    };

    Complex.magnitude = function(x) {
      return Math.sqrt(x.re * x.re + x.im * x.im);
    };

    Complex.direction = direction = function(x) {
      return Math.atan2(x.im, x.re);
    };

    Complex.sin = function(x) {
      return negitimes(sinh(itimes(x)));
    };

    Complex.cos = function(x) {
      return cosh(itimes(x));
    };

    Complex.tan = function(x) {
      return negitimes(tanh(itimes(x)));
    };

    Complex.asin = asin = function(x) {
      x = complexify(x);
      return negitimes(log(add(itimes(x), sqrt(subtract(1, pow(x, 2))))));
    };

    Complex.acos = acos = function(x) {
      var r;
      x = complexify(x);
      r = negitimes(log(add(x, sqrt(subtract(pow(x, 2), 1)))));
      if (r instanceof Complex && (r.re < 0 || (r.re === 0 && r.im < 0))) {
        return negate(r);
      } else {
        return r;
      }
    };

    Complex.atan = atan = function(x) {
      var ix;
      x = complexify(x);
      ix = itimes(x);
      return multiply(new Complex(0, .5), subtract(log(subtract(1, ix)), log(add(1, ix))));
    };

    Complex.sinh = sinh = function(x) {
      var a;
      a = exp(x);
      return multiply(0.5, subtract(a, divide(1, a)));
    };

    Complex.cosh = cosh = function(x) {
      var a;
      a = exp(x);
      return multiply(0.5, add(a, divide(1, a)));
    };

    Complex.tanh = tanh = function(x) {
      var a, b;
      a = exp(x);
      b = divide(1, a);
      return divide(subtract(a, b), add(a, b));
    };

    Complex.asinh = function(x) {
      return itimes(asin(negitimes(x)));
    };

    Complex.acosh = function(x) {
      var sign;
      x = complexify(x);
      sign = x.im > 0 || (x.im === 0 && x.re <= 1) ? 1 : -1;
      return multiply(new Complex(0, sign), acos(x));
    };

    Complex.atanh = function(x) {
      return itimes(atan(negitimes(x)));
    };

    Complex.floor = floor = function(x) {
      var i, im, r, re, _ref, _ref1;
      if (typeof x === 'number') {
        return Math.floor(x);
      } else {
        x = complexify(x);
        _ref = [Math.floor(x.re), Math.floor(x.im)], re = _ref[0], im = _ref[1];
        _ref1 = [x.re - re, x.im - im], r = _ref1[0], i = _ref1[1];
        if (r + i >= 1) {
          if (r >= i) {
            re++;
          } else {
            im++;
          }
        }
        return simplify(re, im);
      }
    };

    Complex.ceil = function(x) {
      var i, im, r, re, _ref, _ref1;
      if (typeof x === 'number') {
        return Math.ceil(x);
      } else {
        x = complexify(x);
        _ref = [Math.ceil(x.re), Math.ceil(x.im)], re = _ref[0], im = _ref[1];
        _ref1 = [re - x.re, im - x.im], r = _ref1[0], i = _ref1[1];
        if (r + i >= 1) {
          if (r >= i) {
            re--;
          } else {
            im--;
          }
        }
        return simplify(re, im);
      }
    };

    iszero = function(x) {
      return x === 0 || (x instanceof Complex && x.re === 0 && x.im === 0);
    };

    Complex.residue = residue = function(x, y) {
      var _ref;
      if ((typeof x === (_ref = typeof y) && _ref === 'number')) {
        if (x === 0) {
          return y;
        } else {
          return y - x * Math.floor(y / x);
        }
      } else {
        if (iszero(x)) {
          return y;
        } else {
          return subtract(y, multiply(x, floor(divide(y, x))));
        }
      }
    };

    Complex.isint = function(x) {
      if (typeof x === 'number') {
        return x === Math.floor(x);
      } else {
        return (x.re === Math.floor(x.re)) && (x.im === Math.floor(x.im));
      }
    };

    firstquadrant = function(x) {
      if (typeof x === 'number') {
        return Math.abs(x);
      } else {
        if (x.re < 0) {
          x = negate(x);
        }
        if (x.im < 0) {
          x = itimes(x);
        }
        if (x.re === 0) {
          x = x.im;
        }
        return x;
      }
    };

    Complex.gcd = gcd = function(x, y) {
      var _ref, _ref1, _ref2;
      if ((typeof x === (_ref = typeof y) && _ref === 'number')) {
        while (y) {
          _ref1 = [y, x % y], x = _ref1[0], y = _ref1[1];
        }
        return Math.abs(x);
      } else {
        while (!iszero(y)) {
          _ref2 = [y, residue(y, x)], x = _ref2[0], y = _ref2[1];
        }
        return firstquadrant(x);
      }
    };

    Complex.lcm = function(x, y) {
      var p;
      p = multiply(x, y);
      if (iszero(p)) {
        return p;
      } else {
        return divide(p, gcd(x, y));
      }
    };

    return Complex;

  })();

  _ref = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], LDC = _ref[0], VEC = _ref[1], GET = _ref[2], SET = _ref[3], MON = _ref[4], DYA = _ref[5], LAM = _ref[6], RET = _ref[7], POP = _ref[8], SPL = _ref[9], JEQ = _ref[10], EMB = _ref[11];
  λ = (function() {
    function λ(code, addr, env) {
      this.code = code;
      this.addr = addr;
      this.env = env;
    }

    λ.prototype.toFunction = function() {
      return (function(_this) {
        return function(x, y) {
          return vm({
            code: _this.code,
            env: _this.env.concat([[x, _this, y]]),
            pc: _this.addr
          });
        };
      })(this);
    };

    λ.prototype.toString = function() {
      return 'λ';
    };

    return λ;

  })();
  vm = function(_arg) {
    var a, code, env, f, frame, n, pc, size, stack, w, x, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5;
    code = _arg.code, env = _arg.env, stack = _arg.stack, pc = _arg.pc;
    if (!(code instanceof Array)) {
      throw Error("\"assert code instanceof Array\" at src/vm.coffee:9");
    }
    if (!(env instanceof Array)) {
      throw Error("\"assert env instanceof Array\" at src/vm.coffee:10");
    }
    for (_i = 0, _len = env.length; _i < _len; _i++) {
      frame = env[_i];
      if (!(frame instanceof Array)) {
        throw Error("\"for frame in env then assert frame instanceof Array\" at src/vm.coffee:11");
      }
    }
    if (stack == null) {
      stack = [];
    }
    if (pc == null) {
      pc = 0;
    }
    while (true) {
      switch (code[pc++]) {
        case LDC:
          stack.push(code[pc++]);
          break;
        case VEC:
          a = [];
          _ref1 = stack.splice(stack.length - code[pc++]);
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            x = _ref1[_j];
            a.push(x.isSimple() ? x.unwrap() : x);
          }
          stack.push(new APLArray(a));
          break;
        case GET:
          stack.push((_ref2 = env[code[pc++]][code[pc++]]) != null ? _ref2 : valueError());
          break;
        case SET:
          env[code[pc++]][code[pc++]] = stack[stack.length - 1];
          break;
        case MON:
          _ref3 = stack.splice(-2), w = _ref3[0], f = _ref3[1];
          if (typeof f === 'function') {
            if (w instanceof λ) {
              w = w.toFunction();
            }
            if (f.cps) {
              f(w, void 0, void 0, function(r) {
                stack.push(r);
                vm({
                  code: code,
                  env: env,
                  stack: stack,
                  pc: pc
                });
              });
              return;
            } else {
              stack.push(f(w));
            }
          } else {
            stack.push(code, pc, env);
            code = f.code;
            pc = f.addr;
            env = f.env.concat([[w, f, null]]);
          }
          break;
        case DYA:
          _ref4 = stack.splice(-3), w = _ref4[0], f = _ref4[1], a = _ref4[2];
          if (typeof f === 'function') {
            if (w instanceof λ) {
              w = w.toFunction();
            }
            if (a instanceof λ) {
              a = a.toFunction();
            }
            if (f.cps) {
              f(w, a, void 0, function(r) {
                stack.push(r);
                vm({
                  code: code,
                  env: env,
                  stack: stack,
                  pc: pc
                });
              });
              return;
            } else {
              stack.push(f(w, a));
            }
          } else {
            stack.push(code, pc, env);
            code = f.code;
            pc = f.addr;
            env = f.env.concat([[w, f, a]]);
          }
          break;
        case LAM:
          size = code[pc++];
          stack.push(new λ(code, pc, env));
          pc += size;
          break;
        case RET:
          if (stack.length === 1) {
            return stack[0];
          }
          _ref5 = stack.splice(-4, 3), code = _ref5[0], pc = _ref5[1], env = _ref5[2];
          break;
        case POP:
          stack.pop();
          break;
        case SPL:
          n = code[pc++];
          a = stack[stack.length - 1].toArray().reverse();
          a = (function() {
            var _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = a.length; _k < _len2; _k++) {
              x = a[_k];
              _results.push(x instanceof APLArray ? x : new APLArray([x], []));
            }
            return _results;
          })();
          if (a.length === 1) {
            a = repeat(a, n);
          } else if (a.length !== n) {
            lengthError();
          }
          stack.push.apply(stack, a);
          break;
        case JEQ:
          n = code[pc++];
          if (!stack[stack.length - 1].toBool()) {
            pc += n;
          }
          break;
        case EMB:
          frame = env[env.length - 1];
          stack.push(code[pc++](frame[0], frame[2]));
          break;
        default:
          aplError('Unrecognized instruction: ' + code[pc - 1] + ', pc:' + pc);
      }
    }
  };

  tokenDefs = [['-', /^(?:[ \t]+|[⍝\#].*)+/], ['L', /^[\n\r]+/], ['⋄', /^[◇⋄]/], ['N', /^¯?(?:0x[\da-f]+|\d*\.?\d+(?:e[+¯]?\d+)?|¯|∞)(?:j¯?(?:0x[\da-f]+|\d*\.?\d+(?:e[+¯]?\d+)?|¯|∞))?/i], ['S', /^(?:'[^']*')+|^(?:"[^"]*")+/], ['.', /^[\(\)\[\]\{\}:;←]/], ['J', /^«[^»]*»/], ['X', /^(?:⎕?[a-z_]\w*|⍺⍺|⍵⍵|∇∇|[^¯'":«»])/i]];
  tokenize = function(s, opts) {
    var a, col, line, m, re, stack, startCol, startLine, t, tokens, type, _i, _len, _ref1;
    if (opts == null) {
      opts = {};
    }
    line = col = 1;
    stack = ['{'];
    tokens = [];
    while (s) {
      startLine = line;
      startCol = col;
      type = null;
      for (_i = 0, _len = tokenDefs.length; _i < _len; _i++) {
        _ref1 = tokenDefs[_i], t = _ref1[0], re = _ref1[1];
        if (!(m = s.match(re))) {
          continue;
        }
        type = t === '.' ? m[0] : t;
        break;
      }
      type || syntaxError('Unrecognized token', {
        file: opts.file,
        line: line,
        col: col,
        s: opts.s
      });
      a = m[0].split('\n');
      line += a.length - 1;
      col = (a.length === 1 ? col : 1) + a[a.length - 1].length;
      s = s.slice(m[0].length);
      if (type !== '-') {
        if (__indexOf.call('([{', type) >= 0) {
          stack.push(type);
        } else if (__indexOf.call(')]}', type) >= 0) {
          stack.pop();
        }
        if (type !== 'L' || stack[stack.length - 1] === '{') {
          tokens.push({
            type: type,
            startLine: startLine,
            startCol: startCol,
            value: m[0],
            endLine: line,
            endCol: col
          });
        }
      }
    }
    tokens.push({
      type: '$',
      value: '',
      startLine: line,
      startCol: col,
      endLine: line,
      endCol: col
    });
    return tokens;
  };

  parse = function(aplCode, opts) {
    var i, parseBody, parseExpr, parserError, result, token, tokens;
    if (opts == null) {
      opts = {};
    }
    tokens = tokenize(aplCode);
    i = 0;
    token = tokens[i++];
    parserError = function(message) {
      return syntaxError(message, {
        file: opts.file,
        line: token.startLine,
        col: token.startCol,
        aplCode: aplCode
      });
    };
    parseBody = function() {
      var body, expr, _ref1, _ref2, _ref3, _ref4;
      body = ['B'];
      while (true) {
        if (_ref1 = token.type, __indexOf.call('$};', _ref1) >= 0) {
          return body;
        }
        while (((_ref2 = token.type) === "⋄" || _ref2 === "L" ? token = tokens[i++] : void 0)) {}
        if (_ref3 = token.type, __indexOf.call('$};', _ref3) >= 0) {
          return body;
        }
        expr = parseExpr();
        if (((_ref4 = token.type) === ":" ? token = tokens[i++] : void 0)) {
          expr = [':', expr, parseExpr()];
        }
        body.push(expr);
      }
    };
    parseExpr = function() {
      var expr, item, t, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      expr = ['.'];
      while (true) {
        t = token;
        if (((_ref1 = token.type) === "N" || _ref1 === "S" || _ref1 === "X" || _ref1 === "J" ? token = tokens[i++] : void 0)) {
          item = [t.type, t.value];
        } else if (((_ref2 = token.type) === "(" ? token = tokens[i++] : void 0)) {
          if (((_ref3 = token.type) === ")" ? token = tokens[i++] : void 0)) {
            item = ['⍬'];
          } else {
            item = parseExpr();
            if (token.type === ')') {
              token = tokens[i++];
            } else {
              parserError("Expected token of type '" + ')' + "' but got '" + token.type + "'");
            }
          }
        } else if (((_ref4 = token.type) === "{" ? token = tokens[i++] : void 0)) {
          item = ['{', parseBody()];
          while (((_ref5 = token.type) === ";" ? token = tokens[i++] : void 0)) {
            item.push(parseBody());
          }
          if (token.type === '}') {
            token = tokens[i++];
          } else {
            parserError("Expected token of type '" + '}' + "' but got '" + token.type + "'");
          }
        } else {
          parserError("Encountered unexpected token of type '" + token.type + "'");
        }
        if (((_ref6 = token.type) === "[" ? token = tokens[i++] : void 0)) {
          item = ['[', item];
          while (true) {
            if (((_ref7 = token.type) === ";" ? token = tokens[i++] : void 0)) {
              item.push(null);
            } else if (token.type === ']') {
              item.push(null);
              break;
            } else {
              item.push(parseExpr());
              if (token.type === ']') {
                break;
              } else {
                if (token.type === ';') {
                  token = tokens[i++];
                } else {
                  parserError("Expected token of type '" + ';' + "' but got '" + token.type + "'");
                }
              }
            }
          }
          if (token.type === ']') {
            token = tokens[i++];
          } else {
            parserError("Expected token of type '" + ']' + "' but got '" + token.type + "'");
          }
        }
        if (((_ref8 = token.type) === "←" ? token = tokens[i++] : void 0)) {
          return expr.concat([['←', item, parseExpr()]]);
        }
        expr.push(item);
        if (_ref9 = token.type, __indexOf.call(')]}:;⋄L$', _ref9) >= 0) {
          return expr;
        }
      }
    };
    result = parseBody();
    if (token.type === '$') {
      token = tokens[i++];
    } else {
      parserError("Expected token of type '" + '$' + "' but got '" + token.type + "'");
    }
    return result;
  };

  vocabulary = {};
  addVocabulary = function(h) {
    var alias, k, v, _i, _len, _ref1, _ref2;
    for (k in h) {
      v = h[k];
      vocabulary[k] = v;
      _ref2 = (_ref1 = v != null ? v.aliases : void 0) != null ? _ref1 : [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        alias = _ref2[_i];
        vocabulary[alias] = v;
      }
    }
  };
  pervasive = function(_arg) {
    var dyad, monad, pervadeDyadic, pervadeMonadic;
    monad = _arg.monad, dyad = _arg.dyad;
    pervadeMonadic = monad ? function(x) {
      var r;
      if (x instanceof APLArray) {
        return x.map(pervadeMonadic);
      } else {
        r = monad(x);
        if (typeof r === 'number' && isNaN(r)) {
          domainError('NaN');
        }
        return r;
      }
    } : nonceError;
    pervadeDyadic = dyad ? function(x, y) {
      var axis, r, tx, ty, xi, yi, _i, _ref1;
      tx = x instanceof APLArray ? (x.isSingleton() ? 1 : 2) : 0;
      ty = y instanceof APLArray ? (y.isSingleton() ? 1 : 2) : 0;
      switch (16 * tx + ty) {
        case 0x00:
          r = dyad(x, y);
          if (typeof r === 'number' && isNaN(r)) {
            domainError('NaN');
          }
          return r;
        case 0x01:
        case 0x02:
          return y.map(function(yi) {
            return pervadeDyadic(x, yi);
          });
        case 0x10:
        case 0x20:
          return x.map(function(xi) {
            return pervadeDyadic(xi, y);
          });
        case 0x12:
          xi = x.data[x.offset];
          return y.map(function(yi) {
            return pervadeDyadic(xi, yi);
          });
        case 0x21:
        case 0x11:
          yi = y.data[y.offset];
          return x.map(function(xi) {
            return pervadeDyadic(xi, yi);
          });
        case 0x22:
          if (x.shape.length !== y.shape.length) {
            rankError();
          }
          for (axis = _i = 0, _ref1 = x.shape.length; _i < _ref1; axis = _i += 1) {
            if (x.shape[axis] !== y.shape[axis]) {
              lengthError();
            }
          }
          return x.map2(y, pervadeDyadic);
        default:
          if (!(0)) {
            throw Error("\"else assert 0\" at src/vocabulary/vhelpers.coffee:40");
          }
      }
    } : nonceError;
    return function(omega, alpha) {
      if (!(omega instanceof APLArray)) {
        throw Error("\"assert ⍵ instanceof APLArray\" at src/vocabulary/vhelpers.coffee:44");
      }
      if (!(alpha instanceof APLArray || (alpha == null))) {
        throw Error("\"assert ⍺ instanceof APLArray or not ⍺?\" at src/vocabulary/vhelpers.coffee:45");
      }
      return (alpha != null ? pervadeDyadic : pervadeMonadic)(omega, alpha);
    };
  };
  numeric = function(f, g) {
    return function(x, y, axis) {
      if (typeof x === 'number' && ((y == null) || typeof y === 'number')) {
        return f(x, y, axis);
      } else {
        x = complexify(x);
        if (y != null) {
          y = complexify(y);
        }
        return g(x, y, axis);
      }
    };
  };
  match = function(x, y) {
    var axis, r, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, xi, yi, _i, _ref1;
    if (x instanceof APLArray) {
      if (!(y instanceof APLArray)) {
        return false;
      } else {
        if (x.shape.length !== y.shape.length) {
          return false;
        }
        for (axis = _i = 0, _ref1 = x.shape.length; _i < _ref1; axis = _i += 1) {
          if (x.shape[axis] !== y.shape[axis]) {
            return false;
          }
        }
        r = true;
        t32 = x;
        t37 = t32.data;
        t39 = t32.shape;
        t41 = t32.stride;
        t33 = y;
        t38 = t33.data;
        t40 = t33.shape;
        t42 = t33.stride;
        if (t39.length !== t40.length) {
          rankError();
        }
        t36 = t39.length;
        while (--t36 >= 0) {
          if (t39[t36] !== t40[t36]) {
            lengthError();
          }
        }
        if (!t32.empty()) {
          t43 = t39.length - 1;
          t34 = t32.offset;
          t35 = t33.offset;
          t44 = Array((t36 = t39.length));
          while (--t36 >= 0) {
            t44[t36] = 0;
          }
          while (true) {
            xi = t37[t34];
            yi = t38[t35];
            if (!match(xi, yi)) {
              r = false;
            }
            t36 = t43;
            while (t36 >= 0 && t44[t36] + 1 === t39[t36]) {
              t34 -= t44[t36] * t41[t36];
              t35 -= t44[t36] * t42[t36];
              t44[t36--] = 0;
            }
            if (t36 < 0) {
              break;
            }
            t44[t36]++;
            t34 += t41[t36];
            t35 += t42[t36];
          }
        }
        return r;
      }
    } else {
      if (y instanceof APLArray) {
        return false;
      } else {
        if (x instanceof Complex && y instanceof Complex) {
          return x.re === y.re && x.im === y.im;
        } else {
          return x === y;
        }
      }
    }
  };
  numApprox = function(x, y) {
    return x === y || Math.abs(x - y) < 1e-11;
  };
  approx = function(x, y) {
    var axis, r, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, xi, yi, _i, _ref1;
    if (x instanceof APLArray) {
      if (!(y instanceof APLArray)) {
        return false;
      } else {
        if (x.shape.length !== y.shape.length) {
          return false;
        }
        for (axis = _i = 0, _ref1 = x.shape.length; _i < _ref1; axis = _i += 1) {
          if (x.shape[axis] !== y.shape[axis]) {
            return false;
          }
        }
        r = true;
        t45 = x;
        t50 = t45.data;
        t52 = t45.shape;
        t54 = t45.stride;
        t46 = y;
        t51 = t46.data;
        t53 = t46.shape;
        t55 = t46.stride;
        if (t52.length !== t53.length) {
          rankError();
        }
        t49 = t52.length;
        while (--t49 >= 0) {
          if (t52[t49] !== t53[t49]) {
            lengthError();
          }
        }
        if (!t45.empty()) {
          t56 = t52.length - 1;
          t47 = t45.offset;
          t48 = t46.offset;
          t57 = Array((t49 = t52.length));
          while (--t49 >= 0) {
            t57[t49] = 0;
          }
          while (true) {
            xi = t50[t47];
            yi = t51[t48];
            if (!approx(xi, yi)) {
              r = false;
            }
            t49 = t56;
            while (t49 >= 0 && t57[t49] + 1 === t52[t49]) {
              t47 -= t57[t49] * t54[t49];
              t48 -= t57[t49] * t55[t49];
              t57[t49--] = 0;
            }
            if (t49 < 0) {
              break;
            }
            t57[t49]++;
            t47 += t54[t49];
            t48 += t55[t49];
          }
        }
        return r;
      }
    } else {
      if (y instanceof APLArray) {
        return false;
      } else if (!((x != null) && (y != null))) {
        return false;
      } else {
        if (typeof x === 'number') {
          x = new Complex(x);
        }
        if (typeof y === 'number') {
          y = new Complex(y);
        }
        if (x instanceof Complex) {
          return y instanceof Complex && numApprox(x.re, y.re) && numApprox(x.im, y.im);
        } else {
          return x === y;
        }
      }
    }
  };
  bool = function(x) {
    if (x !== 0 && x !== 1) {
      return domainError();
    } else {
      return x;
    }
  };
  getAxisList = function(axes, rank) {
    var a, i, tmp58, tmp59, tmp60, x, _i, _len, _ref1, _ref2;
    if (!((tmp58 = (rank)) === ~~tmp58 && (0) <= tmp58)) {
      throw Error("\"assert isInt rank, 0\" at src/vocabulary/vhelpers.coffee:118");
    }
    if (axes == null) {
      return [];
    }
    if (!(axes instanceof APLArray)) {
      throw Error("\"assert axes instanceof APLArray\" at src/vocabulary/vhelpers.coffee:120");
    }
    if (axes.shape.length !== 1 || axes.shape[0] !== 1) {
      syntaxError();
    }
    a = axes.unwrap();
    if (a instanceof APLArray) {
      a = a.toArray();
      for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
        x = a[i];
        if (!((tmp59 = (x)) === ~~tmp59 && ((0) <= (_ref1 = tmp59) && _ref1 < (rank)))) {
          domainError();
        }
        if (__indexOf.call(a.slice(0, i), x) >= 0) {
          domainError('Non-unique axes');
        }
      }
      return a;
    } else if ((tmp60 = (a)) === ~~tmp60 && ((0) <= (_ref2 = tmp60) && _ref2 < (rank))) {
      return [a];
    } else {
      return domainError();
    }
  };
  withIdentity = function(x, f) {
    f.identity = x instanceof APLArray ? x : APLArray.scalar(x);
    return f;
  };
  adverb = function(f) {
    f.isAdverb = true;
    return f;
  };
  conjunction = function(f) {
    f.isConjunction = true;
    return f;
  };
  cps = function(f) {
    f.cps = true;
    return f;
  };
  aka = function(aliases, f) {
    if (typeof aliases === 'string') {
      aliases = [aliases];
    } else {
      if (!(aliases instanceof Array)) {
        throw Error("\"assert aliases instanceof Array\" at src/vocabulary/vhelpers.coffee:146");
      }
    }
    f.aliases = aliases;
    return f;
  };
  addVocabulary({
    '+': withIdentity(0, pervasive({
      monad: numeric((function(x) {
        return x;
      }), Complex.conjugate),
      dyad: numeric((function(y, x) {
        return x + y;
      }), function(y, x) {
        return Complex.add(x, y);
      })
    })),
    '-': aka('−', withIdentity(0, pervasive({
      monad: numeric((function(x) {
        return -x;
      }), Complex.negate),
      dyad: numeric((function(y, x) {
        return x - y;
      }), function(y, x) {
        return Complex.subtract(x, y);
      })
    }))),
    '×': withIdentity(1, pervasive({
      monad: numeric((function(x) {
        return (x > 0) - (x < 0);
      }), function(x) {
        var d;
        d = Math.sqrt(x.re * x.re + x.im * x.im);
        return simplify(x.re / d, x.im / d);
      }),
      dyad: numeric((function(y, x) {
        return x * y;
      }), function(y, x) {
        return Complex.multiply(x, y);
      })
    })),
    '÷': withIdentity(1, pervasive({
      monad: numeric((function(x) {
        return 1 / x;
      }), function(x) {
        var d;
        d = x.re * x.re + x.im * x.im;
        return simplify(x.re / d, -x.im / d);
      }),
      dyad: numeric((function(y, x) {
        return x / y;
      }), function(y, x) {
        return Complex.divide(x, y);
      })
    })),
    '*': aka('⋆', withIdentity(1, pervasive({
      monad: exp = numeric(Math.exp, Complex.exp),
      dyad: function(y, x) {
        return Complex.pow(x, y);
      }
    }))),
    '⍟': pervasive({
      monad: Complex.log,
      dyad: function(y, x) {
        var _ref1;
        if ((typeof x === (_ref1 = typeof y) && _ref1 === 'number') && x > 0 && y > 0) {
          return Math.log(y) / Math.log(x);
        } else {
          return Complex.divide(Complex.log(y), Complex.log(x));
        }
      }
    }),
    '|': aka('∣', withIdentity(0, pervasive({
      monad: numeric((function(x) {
        return Math.abs(x);
      }), Complex.magnitude),
      dyad: function(y, x) {
        return Complex.residue(x, y);
      }
    })))
  });
  addVocabulary({
    '\\': adverb(function(omega, alpha, axis) {
      if (typeof omega === 'function') {
        return scan(omega, void 0, axis);
      } else {
        return expand(omega, alpha, axis);
      }
    }),
    '⍀': adverb(function(omega, alpha, axis) {
      if (axis == null) {
        axis = APLArray.zero;
      }
      if (typeof omega === 'function') {
        return scan(omega, void 0, axis);
      } else {
        return expand(omega, alpha, axis);
      }
    })
  });
  scan = function(f, g, axis) {
    if (!(typeof g === 'undefined')) {
      throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/backslash.coffee:44");
    }
    return function(omega, alpha) {
      if (!(alpha == null)) {
        throw Error("\"assert not ⍺?\" at src/vocabulary/backslash.coffee:46");
      }
      if (!omega.shape.length) {
        return omega;
      }
      axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
      return omega.map(function(x, indices) {
        var a, index, j, p, y, _i, _j, _len, _ref1;
        p = omega.offset;
        for (a = _i = 0, _len = indices.length; _i < _len; a = ++_i) {
          index = indices[a];
          p += index * omega.stride[a];
        }
        if (!(x instanceof APLArray)) {
          x = APLArray.scalar(x);
        }
        for (j = _j = 0, _ref1 = indices[axis]; _j < _ref1; j = _j += 1) {
          p -= omega.stride[axis];
          y = omega.data[p];
          if (!(y instanceof APLArray)) {
            y = APLArray.scalar(y);
          }
          x = f(x, y);
        }
        if (!x.shape.length) {
          x = x.unwrap();
        }
        return x;
      });
    };
  };
  expand = function(omega, alpha, axis) {
    var a, b, data, filler, i, indices, p, shape, tmp61, x, _i, _len, _ref1;
    if (!omega.shape.length) {
      nonceError('Expand of scalar not implemented');
    }
    axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
    if (alpha.shape.length > 1) {
      rankError();
    }
    a = alpha.toArray();
    shape = omega.shape.slice(0);
    shape[axis] = a.length;
    b = [];
    i = 0;
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      if (!((tmp61 = (x)) === ~~tmp61 && ((0) <= (_ref1 = tmp61) && _ref1 < (2)))) {
        domainError();
      }
      b.push(x > 0 ? i++ : null);
    }
    if (i !== omega.shape[axis]) {
      lengthError();
    }
    data = [];
    if (shape[axis] !== 0 && !omega.empty()) {
      filler = omega.getPrototype();
      p = omega.offset;
      indices = repeat([0], shape.length);
      while (true) {
        x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;
        data.push(x);
        i = shape.length - 1;
        while (i >= 0 && indices[i] + 1 === shape[i]) {
          if (i !== axis) {
            p -= omega.stride[i] * indices[i];
          }
          indices[i--] = 0;
        }
        if (i < 0) {
          break;
        }
        if (i !== axis) {
          p += omega.stride[i];
        }
        indices[i]++;
      }
    }
    return new APLArray(data, shape);
  };
  addVocabulary({
    '○': pervasive({
      monad: numeric((function(x) {
        return Math.PI * x;
      }), function(x) {
        return new Complex(Math.PI * x.re, Math.PI * x.im);
      }),
      dyad: function(x, i) {
        var a, b, t;
        if (typeof x === 'number') {
          switch (i) {
            case -12:
              return Complex.exp(simplify(0, x));
            case -11:
              return simplify(0, x);
            case -10:
              return x;
            case -9:
              return x;
            case -8:
              return simplify(0, -Math.sqrt(1 + x * x));
            case -7:
              return Complex.atanh(x);
            case -6:
              return Complex.acosh(x);
            case -5:
              return Complex.asinh(x);
            case -4:
              t = Complex.sqrt(x * x - 1);
              if (x < -1) {
                return -t;
              } else {
                return t;
              }
              break;
            case -3:
              return Complex.atan(x);
            case -2:
              return Complex.acos(x);
            case -1:
              return Complex.asin(x);
            case 0:
              return Complex.sqrt(1 - x * x);
            case 1:
              return Math.sin(x);
            case 2:
              return Math.cos(x);
            case 3:
              return Math.tan(x);
            case 4:
              return Math.sqrt(1 + x * x);
            case 5:
              a = Math.exp(x);
              b = 1 / a;
              return 0.5 * (a - b);
            case 6:
              a = Math.exp(x);
              b = 1 / a;
              return 0.5 * (a + b);
            case 7:
              a = Math.exp(x);
              b = 1 / a;
              return (a - b) / (a + b);
            case 8:
              return Complex.sqrt(-1 - x * x);
            case 9:
              return x;
            case 10:
              return Math.abs(x);
            case 11:
              return 0;
            case 12:
              return 0;
            default:
              return domainError('Unknown circular or hyperbolic function ' + i);
          }
        } else if (x instanceof Complex) {
          switch (i) {
            case -12:
              return Complex.exp(simplify(-x.im, x.re));
            case -11:
              return Complex.itimes(x);
            case -10:
              return Complex.conjugate(x);
            case -9:
              return x;
            case -8:
              t = Complex.subtract(-1, Complex.multiply(x, x));
              return Complex.negate(Complex.sqrt(t));
            case -7:
              return Complex.atanh(x);
            case -6:
              return Complex.acosh(x);
            case -5:
              return Complex.asinh(x);
            case -4:
              if (x.re === -1 && x.im === 0) {
                return 0;
              } else {
                a = Complex.add(x, 1);
                b = Complex.subtract(x, 1);
                return Complex.multiply(a, Complex.sqrt(Complex.divide(b, a)));
              }
              break;
            case -3:
              return Complex.atan(x);
            case -2:
              return Complex.acos(x);
            case -1:
              return Complex.asin(x);
            case 0:
              return Complex.sqrt(Complex.subtract(1, Complex.multiply(x, x)));
            case 1:
              return Complex.sin(x);
            case 2:
              return Complex.cos(x);
            case 3:
              return Complex.tan(x);
            case 4:
              return Complex.sqrt(Complex.add(1, Complex.multiply(x, x)));
            case 5:
              return Complex.sinh(x);
            case 6:
              return Complex.cosh(x);
            case 7:
              return Complex.tanh(x);
            case 8:
              return Complex.sqrt(Complex.subtract(-1, Complex.multiply(x, x)));
            case 9:
              return x.re;
            case 10:
              return Complex.magnitude(x);
            case 11:
              return x.im;
            case 12:
              return Complex.direction(x);
            default:
              return domainError('Unknown circular or hyperbolic function ' + i);
          }
        } else {
          return domainError();
        }
      }
    })
  });
  addVocabulary({
    ',': function(omega, alpha, axis) {
      var a, data, i, nAxes, p, pIndices, q, r, rStride, s, shape, stride, tmp62, tmp63, tmp64, tmp65, tmp66, tmp67, tmp68, _i, _j, _ref1, _ref2, _ref3;
      if (alpha) {
        nAxes = Math.max(alpha.shape.length, omega.shape.length);
        if (axis) {
          axis = axis.unwrap();
          if (typeof axis !== 'number') {
            domainError();
          }
          if (nAxes && !((0 <= axis && axis < nAxes))) {
            rankError();
          }
        } else {
          axis = nAxes - 1;
        }
        if ((alpha.shape.length === (_ref1 = omega.shape.length) && _ref1 === 0)) {
          return new APLArray([alpha.unwrap(), omega.unwrap()]);
        } else if (!alpha.shape.length) {
          s = omega.shape.slice(0);
          if ((tmp62 = (axis)) === ~~tmp62) {
            s[axis] = 1;
          }
          alpha = new APLArray([alpha.unwrap()], s, repeat([0], omega.shape.length));
        } else if (!omega.shape.length) {
          s = alpha.shape.slice(0);
          if ((tmp63 = (axis)) === ~~tmp63) {
            s[axis] = 1;
          }
          omega = new APLArray([omega.unwrap()], s, repeat([0], alpha.shape.length));
        } else if (alpha.shape.length + 1 === omega.shape.length) {
          if (!((tmp64 = (axis)) === ~~tmp64)) {
            rankError();
          }
          shape = alpha.shape.slice(0);
          shape.splice(axis, 0, 1);
          stride = alpha.stride.slice(0);
          stride.splice(axis, 0, 0);
          alpha = new APLArray(alpha.data, shape, stride, alpha.offset);
        } else if (alpha.shape.length === omega.shape.length + 1) {
          if (!((tmp65 = (axis)) === ~~tmp65)) {
            rankError();
          }
          shape = omega.shape.slice(0);
          shape.splice(axis, 0, 1);
          stride = omega.stride.slice(0);
          stride.splice(axis, 0, 0);
          omega = new APLArray(omega.data, shape, stride, omega.offset);
        } else if (alpha.shape.length !== omega.shape.length) {
          rankError();
        }
        if (!(alpha.shape.length === omega.shape.length)) {
          throw Error("\"assert ⍴⍴(⍺) is ⍴⍴(⍵)\" at src/vocabulary/comma.coffee:59");
        }
        for (i = _i = 0, _ref2 = alpha.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
          if (i !== axis && alpha.shape[i] !== omega.shape[i]) {
            lengthError();
          }
        }
        shape = alpha.shape.slice(0);
        if ((tmp66 = (axis)) === ~~tmp66) {
          shape[axis] += omega.shape[axis];
        } else {
          shape.splice(Math.ceil(axis), 0, 2);
        }
        data = Array(prod(shape));
        stride = Array(shape.length);
        stride[shape.length - 1] = 1;
        for (i = _j = _ref3 = shape.length - 2; _j >= 0; i = _j += -1) {
          stride[i] = stride[i + 1] * shape[i + 1];
        }
        if ((tmp67 = (axis)) === ~~tmp67) {
          rStride = stride;
        } else {
          rStride = stride.slice(0);
          rStride.splice(Math.ceil(axis), 1);
        }
        if (!alpha.empty()) {
          r = 0;
          p = alpha.offset;
          pIndices = repeat([0], alpha.shape.length);
          while (true) {
            data[r] = alpha.data[p];
            a = pIndices.length - 1;
            while (a >= 0 && pIndices[a] + 1 === alpha.shape[a]) {
              p -= pIndices[a] * alpha.stride[a];
              r -= pIndices[a] * rStride[a];
              pIndices[a--] = 0;
            }
            if (a < 0) {
              break;
            }
            p += alpha.stride[a];
            r += rStride[a];
            pIndices[a]++;
          }
        }
        if (!omega.empty()) {
          r = (tmp68 = (axis)) === ~~tmp68 ? stride[axis] * alpha.shape[axis] : stride[Math.ceil(axis)];
          q = omega.offset;
          pIndices = repeat([0], omega.shape.length);
          while (true) {
            data[r] = omega.data[q];
            a = pIndices.length - 1;
            while (a >= 0 && pIndices[a] + 1 === omega.shape[a]) {
              q -= pIndices[a] * omega.stride[a];
              r -= pIndices[a] * rStride[a];
              pIndices[a--] = 0;
            }
            if (a < 0) {
              break;
            }
            q += omega.stride[a];
            r += rStride[a];
            pIndices[a]++;
          }
        }
        return new APLArray(data, shape, stride);
      } else {
        return new APLArray(omega.toArray());
      }
    }
  });
  addVocabulary({
    '=': withIdentity(1, pervasive({
      dyad: eq = function(y, x) {
        if (x instanceof Complex && y instanceof Complex) {
          return +(x.re === y.re && x.im === y.im);
        } else {
          return +(x === y);
        }
      }
    })),
    '≠': withIdentity(0, pervasive({
      dyad: function(y, x) {
        return 1 - eq(y, x);
      }
    })),
    '<': withIdentity(0, pervasive({
      dyad: function(y, x, t69) {
        if (typeof y === 'number' && ((x == null) || typeof x === 'number')) {
          return +(x < y);
        } else {
          return domainError();
        }
      }
    })),
    '>': withIdentity(0, pervasive({
      dyad: function(y, x, t70) {
        if (typeof y === 'number' && ((x == null) || typeof x === 'number')) {
          return +(x > y);
        } else {
          return domainError();
        }
      }
    })),
    '≤': withIdentity(1, pervasive({
      dyad: function(y, x, t71) {
        if (typeof y === 'number' && ((x == null) || typeof x === 'number')) {
          return +(x <= y);
        } else {
          return domainError();
        }
      }
    })),
    '≥': withIdentity(1, pervasive({
      dyad: function(y, x, t72) {
        if (typeof y === 'number' && ((x == null) || typeof x === 'number')) {
          return +(x >= y);
        } else {
          return domainError();
        }
      }
    })),
    '≡': function(omega, alpha) {
      if (alpha) {
        return APLArray.bool[+match(omega, alpha)];
      } else {
        return new APLArray([depthOf(omega)], []);
      }
    }
  });
  depthOf = function(x) {
    var r, t73, t74, t75, t76, t77, t78, t79, t80, y;
    if (x instanceof APLArray) {
      if ((!x.shape.length) && (!(x.data[0] instanceof APLArray))) {
        return 0;
      }
      r = 0;
      t73 = x;
      if (!t73.empty()) {
        t75 = t73.data;
        t76 = t73.shape;
        t77 = t73.stride;
        t78 = t76.length - 1;
        t80 = t73.offset;
        t79 = [];
        t74 = t76.length;
        while (--t74 >= 0) {
          t79.push(0);
        }
        while (true) {
          y = t75[t80];
          r = Math.max(r, depthOf(y));
          t74 = t78;
          while (t74 >= 0 && t79[t74] + 1 === t76[t74]) {
            t80 -= t79[t74] * t77[t74];
            t79[t74--] = 0;
          }
          if (t74 < 0) {
            break;
          }
          t79[t74]++;
          t80 += t77[t74];
        }
      }
      return r + 1;
    } else {
      return 0;
    }
  };
  addVocabulary({
    '∘': conjunction(function(g, f) {
      if (typeof f === 'function') {
        if (typeof g === 'function') {
          return function(omega, alpha) {
            return f(g(omega), alpha);
          };
        } else {
          return function(omega, alpha) {
            if (!(alpha == null)) {
              throw Error("\"assert not ⍺?\" at src/vocabulary/compose.coffee:20");
            }
            return f(g, omega);
          };
        }
      } else {
        if (!(typeof g === 'function')) {
          throw Error("\"assert typeof g is 'function'\" at src/vocabulary/compose.coffee:23");
        }
        return function(omega, alpha) {
          if (!(alpha == null)) {
            throw Error("\"assert not ⍺?\" at src/vocabulary/compose.coffee:25");
          }
          return g(omega, f);
        };
      }
    })
  });
  addVocabulary({
    '∪': function(omega, alpha) {
      var a, data, t81, t82, t83, t84, t85, t86, t87, t88, t89, t90, t91, t92, t93, t94, t95, t96, x, _i, _len, _ref1;
      if (alpha) {
        data = [];
        _ref1 = [alpha, omega];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          a = _ref1[_i];
          if (a.shape.length > 1) {
            rankError();
          }
          t81 = a;
          if (!t81.empty()) {
            t83 = t81.data;
            t84 = t81.shape;
            t85 = t81.stride;
            t86 = t84.length - 1;
            t88 = t81.offset;
            t87 = [];
            t82 = t84.length;
            while (--t82 >= 0) {
              t87.push(0);
            }
            while (true) {
              x = t83[t88];
              if (!contains(data, x)) {
                data.push(x);
              }
              t82 = t86;
              while (t82 >= 0 && t87[t82] + 1 === t84[t82]) {
                t88 -= t87[t82] * t85[t82];
                t87[t82--] = 0;
              }
              if (t82 < 0) {
                break;
              }
              t87[t82]++;
              t88 += t85[t82];
            }
          }
        }
        return new APLArray(data);
      } else {
        data = [];
        t89 = omega;
        if (!t89.empty()) {
          t91 = t89.data;
          t92 = t89.shape;
          t93 = t89.stride;
          t94 = t92.length - 1;
          t96 = t89.offset;
          t95 = [];
          t90 = t92.length;
          while (--t90 >= 0) {
            t95.push(0);
          }
          while (true) {
            x = t91[t96];
            if (!contains(data, x)) {
              data.push(x);
            }
            t90 = t94;
            while (t90 >= 0 && t95[t90] + 1 === t92[t90]) {
              t96 -= t95[t90] * t93[t90];
              t95[t90--] = 0;
            }
            if (t90 < 0) {
              break;
            }
            t95[t90]++;
            t96 += t93[t90];
          }
        }
        return new APLArray(data);
      }
    },
    '∩': function(omega, alpha) {
      var b, data, x, _i, _len, _ref1;
      if (alpha) {
        data = [];
        b = omega.toArray();
        _ref1 = alpha.toArray();
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          x = _ref1[_i];
          if (contains(b, x)) {
            data.push(x);
          }
        }
        return new APLArray(data);
      } else {
        return nonceError();
      }
    }
  });
  contains = function(a, x) {
    var y, _i, _len;
    if (!(a instanceof Array)) {
      throw Error("\"assert a instanceof Array\" at src/vocabulary/cupcap.coffee:56");
    }
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      y = a[_i];
      if (match(x, y)) {
        return true;
      }
    }
    return false;
  };
  addVocabulary({
    '⊥': function(omega, alpha) {
      var a, b, data, firstDimB, i, j, k, lastDimA, x, y, z, _i, _j, _k, _ref1, _ref2, _ref3;
      if (!alpha) {
        throw Error("\"assert ⍺\" at src/vocabulary/decode.coffee:53");
      }
      if (!alpha.shape.length) {
        alpha = new APLArray([alpha.unwrap()]);
      }
      if (!omega.shape.length) {
        omega = new APLArray([omega.unwrap()]);
      }
      lastDimA = alpha.shape[alpha.shape.length - 1];
      firstDimB = omega.shape[0];
      if (lastDimA !== 1 && firstDimB !== 1 && lastDimA !== firstDimB) {
        lengthError();
      }
      a = alpha.toArray();
      b = omega.toArray();
      data = [];
      for (i = _i = 0, _ref1 = a.length / lastDimA; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        for (j = _j = 0, _ref2 = b.length / firstDimB; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
          x = a.slice(i * lastDimA, (i + 1) * lastDimA);
          y = (function() {
            var _k, _results;
            _results = [];
            for (k = _k = 0; 0 <= firstDimB ? _k < firstDimB : _k > firstDimB; k = 0 <= firstDimB ? ++_k : --_k) {
              _results.push(b[j + k * (b.length / firstDimB)]);
            }
            return _results;
          })();
          if (x.length === 1) {
            x = (function() {
              var _k, _ref3, _results;
              _results = [];
              for (_k = 0, _ref3 = y.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; 0 <= _ref3 ? _k++ : _k--) {
                _results.push(x[0]);
              }
              return _results;
            })();
          }
          if (y.length === 1) {
            y = (function() {
              var _k, _ref3, _results;
              _results = [];
              for (_k = 0, _ref3 = x.length; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; 0 <= _ref3 ? _k++ : _k--) {
                _results.push(y[0]);
              }
              return _results;
            })();
          }
          z = y[0];
          for (k = _k = 1, _ref3 = y.length; 1 <= _ref3 ? _k < _ref3 : _k > _ref3; k = 1 <= _ref3 ? ++_k : --_k) {
            z = z * x[k] + y[k];
          }
          data.push(z);
        }
      }
      return new APLArray(data, alpha.shape.slice(0, -1).concat(omega.shape.slice(1)));
    }
  });
  addVocabulary({
    '.': conjunction(function(g, f) {
      if (f === vocabulary['∘']) {
        return outerProduct(g);
      } else {
        return innerProduct(g, f);
      }
    })
  });
  outerProduct = function(f) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/dot.coffee:39");
    }
    return function(omega, alpha) {
      var a, b, data, x, y, z, _i, _j, _len, _len1;
      if (!alpha) {
        syntaxError('Adverb ∘. (Outer product) can be applied to dyadic verbs only');
      }
      a = alpha.toArray();
      b = omega.toArray();
      data = [];
      for (_i = 0, _len = a.length; _i < _len; _i++) {
        x = a[_i];
        for (_j = 0, _len1 = b.length; _j < _len1; _j++) {
          y = b[_j];
          if (!(x instanceof APLArray)) {
            x = APLArray.scalar(x);
          }
          if (!(y instanceof APLArray)) {
            y = APLArray.scalar(y);
          }
          z = f(y, x);
          if (!z.shape.length) {
            z = z.unwrap();
          }
          data.push(z);
        }
      }
      return new APLArray(data, alpha.shape.concat(omega.shape));
    };
  };
  innerProduct = function(g, f) {
    var F, G;
    F = vocabulary['¨'](reduce(f));
    G = outerProduct(g);
    return function(omega, alpha) {
      if (!alpha.shape.length) {
        alpha = new APLArray([alpha.unwrap()]);
      }
      if (!omega.shape.length) {
        omega = new APLArray([omega.unwrap()]);
      }
      return F(G(vocabulary['⊂'](omega, void 0, new APLArray([0])), vocabulary['⊂'](alpha, void 0, new APLArray([alpha.shape.length - 1]))));
    };
  };
  addVocabulary({
    '↓': function(omega, alpha, axis) {
      var a, array, data, i, ishape, obound, offset, oshape, shape, tmp97, x, _i, _j, _k, _len, _len1;
      if (alpha) {
        if (alpha.shape.length > 1) {
          rankError();
        }
        a = alpha.toArray();
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          x = a[_i];
          if (!((tmp97 = (x)) === ~~tmp97)) {
            domainError();
          }
        }
        if (!omega.shape.length) {
          omega = new APLArray(omega.data, repeat([1], a.length), repeat([0], a.length), omega.offset);
        } else {
          if (a.length > omega.shape.length) {
            rankError();
          }
        }
        shape = omega.shape.slice(0);
        offset = omega.offset;
        for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
          x = a[i];
          shape[i] = Math.max(0, omega.shape[i] - Math.abs(x));
          if (x > 0) {
            offset += x * omega.stride[i];
          }
        }
        if (prod(shape) === 0) {
          return new APLArray([], shape);
        } else {
          return new APLArray(omega.data, shape, omega.stride, offset);
        }
      } else {
        if (!omega.shape.length) {
          nonceError('Split of scalar not implemented');
        }
        oshape = omega.shape.slice(0, omega.shape.length - 1);
        obound = oshape.reduce((function(a, b) {
          return a * b;
        }), 1);
        ishape = omega.shape[omega.shape.length - 1];
        array = omega.toArray();
        data = [];
        for (i = _k = 0; 0 <= obound ? _k < obound : _k > obound; i = 0 <= obound ? ++_k : --_k) {
          offset = i * ishape;
          data.push(new APLArray(array.slice(offset, offset + ishape)));
        }
        return new APLArray(data, oshape);
      }
    }
  });
  addVocabulary({
    '¨': adverb(function(f, g) {
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/vocabulary/each.coffee:18");
      }
      if (!(typeof g === 'undefined')) {
        throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/each.coffee:19");
      }
      return function(omega, alpha) {
        var x, y;
        if (!alpha) {
          return omega.map(function(x) {
            var r;
            if (!(x instanceof APLArray)) {
              x = new APLArray([x], []);
            }
            r = f(x);
            if (!(r instanceof APLArray)) {
              throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:25");
            }
            if (r.shape.length) {
              return r;
            } else {
              return r.unwrap();
            }
          });
        } else if (arrayEquals(alpha.shape, omega.shape)) {
          return omega.map2(alpha, function(x, y) {
            var r;
            if (!(x instanceof APLArray)) {
              x = new APLArray([x], []);
            }
            if (!(y instanceof APLArray)) {
              y = new APLArray([y], []);
            }
            r = f(x, y);
            if (!(r instanceof APLArray)) {
              throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:32");
            }
            if (r.shape.length) {
              return r;
            } else {
              return r.unwrap();
            }
          });
        } else if (alpha.isSingleton()) {
          y = alpha.data[0] instanceof APLArray ? alpha.unwrap() : alpha;
          return omega.map(function(x) {
            var r;
            if (!(x instanceof APLArray)) {
              x = new APLArray([x], []);
            }
            r = f(x, y);
            if (!(r instanceof APLArray)) {
              throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:39");
            }
            if (r.shape.length) {
              return r;
            } else {
              return r.unwrap();
            }
          });
        } else if (omega.isSingleton()) {
          x = omega.data[0] instanceof APLArray ? omega.unwrap() : omega;
          return alpha.map(function(y) {
            var r;
            if (!(y instanceof APLArray)) {
              y = new APLArray([y], []);
            }
            r = f(x, y);
            if (!(r instanceof APLArray)) {
              throw Error("\"assert r instanceof APLArray\" at src/vocabulary/each.coffee:46");
            }
            if (r.shape.length) {
              return r;
            } else {
              return r.unwrap();
            }
          });
        } else {
          return lengthError();
        }
      };
    })
  });
  addVocabulary({
    '⊤': function(omega, alpha) {
      var a, b, data, i, isNeg, j, k, m, n, shape, x, y, _i, _j, _k, _len, _ref1;
      if (!alpha) {
        throw Error("\"assert ⍺\" at src/vocabulary/encode.coffee:40");
      }
      a = alpha.toArray();
      b = omega.toArray();
      shape = alpha.shape.concat(omega.shape);
      data = Array(prod(shape));
      n = alpha.shape.length ? alpha.shape[0] : 1;
      m = a.length / n;
      for (i = _i = 0; 0 <= m ? _i < m : _i > m; i = 0 <= m ? ++_i : --_i) {
        for (j = _j = 0, _len = b.length; _j < _len; j = ++_j) {
          y = b[j];
          if (isNeg = y < 0) {
            y = -y;
          }
          for (k = _k = _ref1 = n - 1; _k >= 0; k = _k += -1) {
            x = a[k * m + i];
            if (x === 0) {
              data[(k * m + i) * b.length + j] = y;
              y = 0;
            } else {
              data[(k * m + i) * b.length + j] = y % x;
              y = Math.round((y - (y % x)) / x);
            }
          }
        }
      }
      return new APLArray(data, shape);
    }
  });
  addVocabulary({
    '∊': aka('∈', function(omega, alpha) {
      var a, data;
      if (alpha) {
        a = omega.toArray();
        return alpha.map(function(x) {
          var y, _i, _len;
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            y = a[_i];
            if (match(x, y)) {
              return 1;
            }
          }
          return 0;
        });
      } else {
        data = [];
        enlist(omega, data);
        return new APLArray(data);
      }
    })
  });
  enlist = function(x, r) {
    var t100, t101, t102, t103, t104, t105, t98, t99, y, _results;
    if (x instanceof APLArray) {
      t98 = x;
      if (!t98.empty()) {
        t100 = t98.data;
        t101 = t98.shape;
        t102 = t98.stride;
        t103 = t101.length - 1;
        t105 = t98.offset;
        t104 = [];
        t99 = t101.length;
        while (--t99 >= 0) {
          t104.push(0);
        }
        _results = [];
        while (true) {
          y = t100[t105];
          enlist(y, r);
          t99 = t103;
          while (t99 >= 0 && t104[t99] + 1 === t101[t99]) {
            t105 -= t104[t99] * t102[t99];
            t104[t99--] = 0;
          }
          if (t99 < 0) {
            break;
          }
          t104[t99]++;
          _results.push(t105 += t102[t99]);
        }
        return _results;
      }
    } else {
      return r.push(x);
    }
  };
  addVocabulary({
    '!': withIdentity(1, pervasive({
      monad: function(x, t107, t108) {
        var tmp106;
        if (typeof x === 'number' && ((t107 == null) || typeof t107 === 'number')) {
          if (!((tmp106 = (x)) === ~~tmp106)) {
            return Γ(x + 1);
          } else if (x < 0) {
            return domainError();
          } else if (x < smallFactorials.length) {
            return smallFactorials[x];
          } else {
            return Math.round(Γ(x + 1));
          }
        } else {
          return domainError();
        }
      },
      dyad: Beta = function(n, k, t111) {
        var r, tmp109, tmp110;
        if (typeof n === 'number' && ((k == null) || typeof k === 'number')) {
          r = (function() {
            switch (4 * negInt(k) + 2 * negInt(n) + negInt(n - k)) {
              case 0x0:
                return Math.exp(lnΓ(n + 1) - lnΓ(k + 1) - lnΓ(n - k + 1));
              case 0x1:
                return 0;
              case 0x2:
                return domainError();
              case 0x3:
                return Math.pow(-1, k) * Beta(k - n - 1, k);
              case 0x4:
                return 0;
              case 0x5:
                break;
              case 0x6:
                return Math.pow(-1, n - k) * Beta(Math.abs(k + 1), Math.abs(n + 1));
              case 0x7:
                return 0;
            }
          })();
          if (((tmp109 = (n)) === ~~tmp109) && ((tmp110 = (k)) === ~~tmp110)) {
            return Math.round(r);
          } else {
            return r;
          }
        } else {
          return domainError();
        }
      }
    }))
  });
  negInt = function(x) {
    var tmp112;
    return ((tmp112 = (x)) === ~~tmp112) && x < 0;
  };
  smallFactorials = (function() {
    var i, x;
    return [x = 1].concat((function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; _i <= 25; i = ++_i) {
        _results.push(x *= i);
      }
      return _results;
    })());
  })();
  _ref1 = (function() {
    var g, g_ln, p, p_ln;
    g = 7;
    p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028, 771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7];
    g_ln = 607 / 128;
    p_ln = [0.99999999999999709182, 57.156235665862923517, -59.597960355475491248, 14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4, 0.46523628927048575665e-4, -0.98374475304879564677e-4, 0.15808870322491248884e-3, -0.21026444172410488319e-3, 0.21743961811521264320e-3, -0.16431810653676389022e-3, 0.84418223983852743293e-4, -0.26190838401581408670e-4, 0.36899182659531622704e-5];
    return {
      lnΓ: function(z) {
        var i, t, x, _i, _ref1;
        if (z < 0) {
          return NaN;
        }
        x = p_ln[0];
        for (i = _i = _ref1 = p_ln.length - 1; _i > 0; i = _i += -1) {
          x += p_ln[i] / (z + i);
        }
        t = z + g_ln + .5;
        return .5 * Math.log(2 * Math.PI) + (z + .5) * Math.log(t) - t + Math.log(x) - Math.log(z);
      },
      Γ: function(z) {
        var i, t, x, _i, _ref1;
        if (z < 0.5) {
          return Math.PI / (Math.sin(Math.PI * z) * Γ(1 - z));
        } else if (z > 100) {
          return Math.exp(lnΓ(z));
        } else {
          z--;
          x = p[0];
          for (i = _i = 1, _ref1 = g + 2; _i < _ref1; i = _i += 1) {
            x += p[i] / (z + i);
          }
          t = z + g + .5;
          return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
        }
      }
    };
  })(), Γ = _ref1.Γ, lnΓ = _ref1.lnΓ;
  addVocabulary({
    '⍎': function(omega, alpha) {
      var c, s, t113, t114, t115, t116, t117, t118, t119, t120;
      if (alpha) {
        return nonceError();
      } else {
        s = '';
        t113 = omega;
        if (!t113.empty()) {
          t115 = t113.data;
          t116 = t113.shape;
          t117 = t113.stride;
          t118 = t116.length - 1;
          t120 = t113.offset;
          t119 = [];
          t114 = t116.length;
          while (--t114 >= 0) {
            t119.push(0);
          }
          while (true) {
            c = t115[t120];
            if (typeof c !== 'string') {
              domainError();
            }
            s += c;
            t114 = t118;
            while (t114 >= 0 && t119[t114] + 1 === t116[t114]) {
              t120 -= t119[t114] * t117[t114];
              t119[t114--] = 0;
            }
            if (t114 < 0) {
              break;
            }
            t119[t114]++;
            t120 += t117[t114];
          }
        }
        return exec(s);
      }
    }
  });
  addVocabulary({
    '⍷': function(omega, alpha) {
      var a, d, data, findShape, i, indices, p, q, stride, _i, _ref2;
      if (alpha) {
        if (alpha.shape.length > omega.shape.length) {
          return new APLArray([0], omega.shape, repeat([0], omega.shape.length));
        }
        if (alpha.shape.length < omega.shape.length) {
          alpha = new APLArray(alpha.data, repeat([1], omega.shape.length - alpha.shape.length).concat(alpha.shape), repeat([0], omega.shape.length - alpha.shape.length).concat(alpha.stride), alpha.offset);
        }
        if (prod(alpha.shape) === 0) {
          return new APLArray([1], omega.shape, repeat([0], omega.shape.length));
        }
        findShape = [];
        for (i = _i = 0, _ref2 = omega.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
          d = omega.shape[i] - alpha.shape[i] + 1;
          if (d <= 0) {
            return new APLArray([0], omega.shape, repeat([0], omega.shape.length));
          }
          findShape.push(d);
        }
        stride = strideForShape(omega.shape);
        data = repeat([0], prod(omega.shape));
        p = omega.offset;
        q = 0;
        indices = repeat([0], findShape.length);
        while (true) {
          data[q] = +match(alpha, new APLArray(omega.data, alpha.shape, omega.stride, p));
          a = findShape.length - 1;
          while (a >= 0 && indices[a] + 1 === findShape[a]) {
            p -= indices[a] * omega.stride[a];
            q -= indices[a] * stride[a];
            indices[a--] = 0;
          }
          if (a < 0) {
            break;
          }
          p += omega.stride[a];
          q += stride[a];
          indices[a]++;
        }
        return new APLArray(data, omega.shape);
      } else {
        return nonceError();
      }
    }
  });
  addVocabulary({
    '⌊': withIdentity(Infinity, pervasive({
      monad: Complex.floor,
      dyad: function(y, x, t121) {
        if (typeof y === 'number' && ((x == null) || typeof x === 'number')) {
          return Math.min(y, x);
        } else {
          return domainError();
        }
      }
    })),
    '⌈': withIdentity(-Infinity, pervasive({
      monad: Complex.ceil,
      dyad: function(y, x, t122) {
        if (typeof y === 'number' && ((x == null) || typeof x === 'number')) {
          return Math.max(y, x);
        } else {
          return domainError();
        }
      }
    }))
  });
  addVocabulary({
    _fork1: function(h, g) {
      if (!(typeof h === 'function')) {
        throw Error("\"assert typeof h is 'function'\" at src/vocabulary/fork.coffee:20");
      }
      if (!(typeof g === 'function')) {
        throw Error("\"assert typeof g is 'function'\" at src/vocabulary/fork.coffee:21");
      }
      return [h, g];
    },
    _fork2: function(_arg, f) {
      var g, h;
      h = _arg[0], g = _arg[1];
      if (!(typeof h === 'function')) {
        throw Error("\"assert typeof h is 'function'\" at src/vocabulary/fork.coffee:25");
      }
      return function(b, a) {
        return g(h(b, a), f(b, a));
      };
    }
  });
  addVocabulary({
    '⍕': function(omega, alpha) {
      var t;
      if (alpha) {
        return nonceError();
      } else {
        t = format(omega);
        return new APLArray(t.join(''), [t.length, t[0].length]);
      }
    }
  });
  format = function(a) {
    var bottom, box, c, cols, d, grid, i, j, k, left, nCols, nRows, r, result, right, rows, sa, step, t, x, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _p, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (typeof a === 'undefined') {
      return ['undefined'];
    } else if (a === null) {
      return ['null'];
    } else if (typeof a === 'string') {
      return [a];
    } else if (typeof a === 'number') {
      r = [('' + a).replace('Infinity', '∞').replace(/-/g, '¯')];
      r.align = 'right';
      return r;
    } else if (typeof a === 'function') {
      return ['λ'];
    } else if (!(a instanceof APLArray)) {
      return ['' + a];
    } else if (prod(a.shape) === 0) {
      return [''];
    } else {
      sa = a.shape;
      a = a.toArray();
      if (!sa.length) {
        return format(a[0]);
      }
      nRows = prod(sa.slice(0, sa.length - 1));
      nCols = sa[sa.length - 1];
      rows = (function() {
        var _i, _results;
        _results = [];
        for (_i = 0; 0 <= nRows ? _i < nRows : _i > nRows; 0 <= nRows ? _i++ : _i--) {
          _results.push({
            height: 0,
            bottomMargin: 0
          });
        }
        return _results;
      })();
      cols = (function() {
        var _i, _results;
        _results = [];
        for (_i = 0; 0 <= nCols ? _i < nCols : _i > nCols; 0 <= nCols ? _i++ : _i--) {
          _results.push({
            type: 0,
            width: 0,
            leftMargin: 0,
            rightMargin: 0
          });
        }
        return _results;
      })();
      grid = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = rows.length; _i < _len; i = ++_i) {
          r = rows[i];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (j = _j = 0, _len1 = cols.length; _j < _len1; j = ++_j) {
              c = cols[j];
              x = a[nCols * i + j];
              box = format(x);
              r.height = Math.max(r.height, box.length);
              c.width = Math.max(c.width, box[0].length);
              c.type = Math.max(c.type, typeof x === 'string' && x.length === 1 ? 0 : !(x instanceof APLArray) ? 1 : 2);
              _results1.push(box);
            }
            return _results1;
          })());
        }
        return _results;
      })();
      step = 1;
      for (d = _i = _ref2 = sa.length - 2; _i >= 1; d = _i += -1) {
        step *= sa[d];
        for (i = _j = _ref3 = step - 1, _ref4 = nRows - 1; step > 0 ? _j < _ref4 : _j > _ref4; i = _j += step) {
          rows[i].bottomMargin++;
        }
      }
      for (j = _k = 0, _len = cols.length; _k < _len; j = ++_k) {
        c = cols[j];
        if (j !== nCols - 1 && !((c.type === (_ref5 = cols[j + 1].type) && _ref5 === 0))) {
          c.rightMargin++;
        }
        if (c.type === 2) {
          c.leftMargin++;
          c.rightMargin++;
        }
      }
      result = [];
      for (i = _l = 0, _len1 = rows.length; _l < _len1; i = ++_l) {
        r = rows[i];
        for (j = _m = 0, _len2 = cols.length; _m < _len2; j = ++_m) {
          c = cols[j];
          t = grid[i][j];
          if (t.align === 'right') {
            left = repeat(' ', c.leftMargin + c.width - t[0].length);
            right = repeat(' ', c.rightMargin);
          } else {
            left = repeat(' ', c.leftMargin);
            right = repeat(' ', c.rightMargin + c.width - t[0].length);
          }
          for (k = _n = 0, _ref6 = t.length; 0 <= _ref6 ? _n < _ref6 : _n > _ref6; k = 0 <= _ref6 ? ++_n : --_n) {
            t[k] = left + t[k] + right;
          }
          bottom = repeat(' ', t[0].length);
          for (_o = _ref7 = t.length, _ref8 = r.height + r.bottomMargin; _ref7 <= _ref8 ? _o < _ref8 : _o > _ref8; _ref7 <= _ref8 ? _o++ : _o--) {
            t.push(bottom);
          }
        }
        for (k = _p = 0, _ref9 = r.height + r.bottomMargin; 0 <= _ref9 ? _p < _ref9 : _p > _ref9; k = 0 <= _ref9 ? ++_p : --_p) {
          result.push(((function() {
            var _q, _results;
            _results = [];
            for (j = _q = 0; 0 <= nCols ? _q < nCols : _q > nCols; j = 0 <= nCols ? ++_q : --_q) {
              _results.push(grid[i][j][k]);
            }
            return _results;
          })()).join(''));
        }
      }
      return result;
    }
  };
  addVocabulary({
    '⍋': function(omega, alpha) {
      return grade(omega, alpha, 1);
    },
    '⍒': function(omega, alpha) {
      return grade(omega, alpha, -1);
    }
  });
  grade = function(omega, alpha, direction) {
    var h, indices, t123, t124, t125, t126, t127, t128, t129, x, _i, _ref2, _results;
    h = {};
    if (alpha) {
      if (!alpha.shape.length) {
        rankError();
      }
      h = {};
      t123 = alpha;
      if (!t123.empty()) {
        t125 = t123.data;
        t126 = t123.shape;
        t127 = t123.stride;
        t128 = t126.length - 1;
        t129 = t123.offset;
        indices = [];
        t124 = t126.length;
        while (--t124 >= 0) {
          indices.push(0);
        }
        while (true) {
          x = t125[t129];
          if (typeof x !== 'string') {
            domainError();
          }
          h[x] = indices[indices.length - 1];
          t124 = t128;
          while (t124 >= 0 && indices[t124] + 1 === t126[t124]) {
            t129 -= indices[t124] * t127[t124];
            indices[t124--] = 0;
          }
          if (t124 < 0) {
            break;
          }
          indices[t124]++;
          t129 += t127[t124];
        }
      }
    }
    if (!omega.shape.length) {
      rankError();
    }
    return new APLArray((function() {
      _results = [];
      for (var _i = 0, _ref2 = omega.shape[0]; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).sort(function(i, j) {
      var a, p, tx, ty, y;
      p = omega.offset;
      indices = repeat([0], omega.shape.length);
      while (true) {
        x = omega.data[p + i * omega.stride[0]];
        y = omega.data[p + j * omega.stride[0]];
        tx = typeof x;
        ty = typeof y;
        if (tx < ty) {
          return -direction;
        }
        if (tx > ty) {
          return direction;
        }
        if (h[x] != null) {
          x = h[x];
        }
        if (h[y] != null) {
          y = h[y];
        }
        if (x < y) {
          return -direction;
        }
        if (x > y) {
          return direction;
        }
        a = indices.length - 1;
        while (a > 0 && indices[a] + 1 === omega.shape[a]) {
          p -= omega.stride[a] * indices[a];
          indices[a--] = 0;
        }
        if (a <= 0) {
          break;
        }
        p += omega.stride[a];
        indices[a]++;
      }
      return (i > j) - (i < j);
    }));
  };
  addVocabulary({
    '⍁': conjunction(function(f, x) {
      var _ref2;
      if (f instanceof APLArray) {
        _ref2 = [x, f], f = _ref2[0], x = _ref2[1];
      }
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/vocabulary/identity.coffee:13");
      }
      if (!(x instanceof APLArray)) {
        throw Error("\"assert x instanceof APLArray\" at src/vocabulary/identity.coffee:14");
      }
      if (!x.isSingleton()) {
        rankError();
      }
      if (x.shape.length) {
        x = APLArray.scalar(x.unwrap());
      }
      return withIdentity(x, function(omega, alpha, axis) {
        return f(omega, alpha, axis);
      });
    })
  });
  addVocabulary({
    '⍳': function(omega, alpha) {
      var A, a, d, data, i, itemData, itemShape, itemStride, j, m, n, p, t138, t139, t140, t141, t142, t143, t144, t145, tmp137, u, _i, _j, _k, _l, _len, _m, _n, _o, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (alpha) {
        if (alpha.shape.length !== 1) {
          rankError();
        }
        return omega.map(function(x) {
          var e, indices, rank, t130, t131, t132, t133, t134, t135, t136, y;
          try {
            rank = alpha.shape;
            t130 = alpha;
            if (!t130.empty()) {
              t132 = t130.data;
              t133 = t130.shape;
              t134 = t130.stride;
              t135 = t133.length - 1;
              t136 = t130.offset;
              indices = [];
              t131 = t133.length;
              while (--t131 >= 0) {
                indices.push(0);
              }
              while (true) {
                y = t132[t136];
                if (match(x, y)) {
                  rank = indices;
                  throw 'break';
                }
                t131 = t135;
                while (t131 >= 0 && indices[t131] + 1 === t133[t131]) {
                  t136 -= indices[t131] * t134[t131];
                  indices[t131--] = 0;
                }
                if (t131 < 0) {
                  break;
                }
                indices[t131]++;
                t136 += t134[t131];
              }
            }
          } catch (_error) {
            e = _error;
            if (e !== 'break') {
              throw e;
            }
          }
          if (rank.length === 1) {
            return rank[0];
          } else {
            return new APLArray(rank);
          }
        });
      } else {
        if (omega.shape.length > 1) {
          rankError();
        }
        a = omega.toArray();
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          d = a[_i];
          if (!((tmp137 = (d)) === ~~tmp137 && (0) <= tmp137)) {
            domainError();
          }
        }
        n = prod(a);
        if (!n) {
          data = [];
        } else if (a.length === 1) {
          data = n <= 0x100 ? new Uint8Array(n) : n <= 0x10000 ? new Uint16Array(n) : n <= 0x100000000 ? new Uint32Array(n) : domainError();
          for (i = _j = 0; _j < n; i = _j += 1) {
            data[i] = i;
          }
        } else {
          m = Math.max.apply(Math, a);
          A = m <= 0x100 ? Uint8Array : m <= 0x10000 ? Uint16Array : m <= 0x100000000 ? Uint32Array : domainError();
          itemData = new A(n * a.length);
          u = n;
          for (i = _k = 0, _ref2 = a.length; _k < _ref2; i = _k += 1) {
            u /= a[i];
            p = n * i;
            for (j = _l = 0, _ref3 = a[i]; _l < _ref3; j = _l += 1) {
              itemData[p] = j;
              t138 = itemData;
              t139 = p;
              t140 = 1;
              t141 = u;
              if (t138 instanceof Array) {
                for (j = _m = _ref4 = t140, _ref5 = t141; _m < _ref5; j = _m += 1) {
                  t138[t139 + j] = t138[t139 + j % t140];
                }
              } else {
                t138 = t138.subarray(t139, t139 + t141);
                while (2 * t140 < t141) {
                  t138.set(t138.subarray(0, t140), t140);
                  t140 *= 2;
                }
                t138.set(t138.subarray(0, t141 - t140), t140);
              }
              p += u;
            }
            t142 = itemData;
            t143 = n * i;
            t144 = a[i] * u;
            t145 = n;
            if (t142 instanceof Array) {
              for (j = _n = _ref6 = t144, _ref7 = t145; _n < _ref7; j = _n += 1) {
                t142[t143 + j] = t142[t143 + j % t144];
              }
            } else {
              t142 = t142.subarray(t143, t143 + t145);
              while (2 * t144 < t145) {
                t142.set(t142.subarray(0, t144), t144);
                t144 *= 2;
              }
              t142.set(t142.subarray(0, t145 - t144), t144);
            }
          }
          data = [];
          itemShape = [a.length];
          itemStride = [n];
          for (i = _o = 0; _o < n; i = _o += 1) {
            data.push(new APLArray(itemData, itemShape, itemStride, i));
          }
        }
        return new APLArray(data, a);
      }
    }
  });
  addVocabulary({
    '⊂': function(omega, alpha, axes) {
      var data, i, indices, p, resultAxes, shape, stride, t146, t147, t148, t149, t150, t151, unitShape, unitStride, x, _i, _ref2, _results;
      if (!(!alpha)) {
        throw Error("\"assert not ⍺\" at src/vocabulary/leftshoe.coffee:13");
      }
      axes = axes != null ? getAxisList(axes, omega.shape.length) : (function() {
        _results = [];
        for (var _i = 0, _ref2 = omega.shape.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; 0 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      if (omega.isSimple()) {
        return omega;
      }
      unitShape = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = axes.length; _j < _len; _j++) {
          i = axes[_j];
          _results1.push(omega.shape[i]);
        }
        return _results1;
      })();
      unitStride = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = axes.length; _j < _len; _j++) {
          i = axes[_j];
          _results1.push(omega.stride[i]);
        }
        return _results1;
      })();
      resultAxes = (function() {
        var _j, _ref3, _results1;
        _results1 = [];
        for (i = _j = 0, _ref3 = omega.shape.length; 0 <= _ref3 ? _j < _ref3 : _j > _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
          if (__indexOf.call(axes, i) < 0) {
            _results1.push(i);
          }
        }
        return _results1;
      })();
      shape = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {
          i = resultAxes[_j];
          _results1.push(omega.shape[i]);
        }
        return _results1;
      })();
      stride = (function() {
        var _j, _len, _results1;
        _results1 = [];
        for (_j = 0, _len = resultAxes.length; _j < _len; _j++) {
          i = resultAxes[_j];
          _results1.push(omega.stride[i]);
        }
        return _results1;
      })();
      data = [];
      t146 = new APLArray(omega.data, shape, stride, omega.offset);
      if (!t146.empty()) {
        t148 = t146.data;
        t149 = t146.shape;
        t150 = t146.stride;
        t151 = t149.length - 1;
        p = t146.offset;
        indices = [];
        t147 = t149.length;
        while (--t147 >= 0) {
          indices.push(0);
        }
        while (true) {
          x = t148[p];
          data.push(new APLArray(omega.data, unitShape, unitStride, p));
          t147 = t151;
          while (t147 >= 0 && indices[t147] + 1 === t149[t147]) {
            p -= indices[t147] * t150[t147];
            indices[t147--] = 0;
          }
          if (t147 < 0) {
            break;
          }
          indices[t147]++;
          p += t150[t147];
        }
      }
      return new APLArray(data, shape);
    }
  });
  addVocabulary({
    '~': pervasive({
      monad: function(x) {
        return +(!bool(x));
      }
    }),
    '∨': withIdentity(0, pervasive({
      dyad: function(y, x) {
        if (!(Complex.isint(x)) || !(Complex.isint(y))) {
          domainError('∨ is implemented only for Gaussian integers');
        }
        return Complex.gcd(x, y);
      }
    })),
    '∧': aka('^', withIdentity(1, pervasive({
      dyad: function(y, x) {
        if (!(Complex.isint(x)) || !(Complex.isint(y))) {
          domainError('∧ is implemented only for Gaussian integers');
        }
        return Complex.lcm(x, y);
      }
    }))),
    '⍱': pervasive({
      dyad: function(y, x, t152) {
        if (typeof y === 'number' && ((x == null) || typeof x === 'number')) {
          return +(!(bool(x) | bool(y)));
        } else {
          return domainError();
        }
      }
    }),
    '⍲': pervasive({
      dyad: function(y, x, t153) {
        if (typeof y === 'number' && ((x == null) || typeof x === 'number')) {
          return +(!(bool(x) & bool(y)));
        } else {
          return domainError();
        }
      }
    })
  });
  addVocabulary({
    '⍣': conjunction(function(g, f) {
      var h, n;
      if (f instanceof APLArray && typeof g === 'function') {
        h = f;
        f = g;
        g = h;
      } else {
        if (!(typeof f === 'function')) {
          throw Error("\"assert typeof f is 'function'\" at src/vocabulary/poweroperator.coffee:15");
        }
      }
      if (typeof g === 'function') {
        return function(omega, alpha) {
          var omega1;
          while (true) {
            omega1 = f(omega, alpha);
            if (g(omega, omega1).toBool()) {
              return omega;
            }
            omega = omega1;
          }
        };
      } else {
        n = g.toInt(0);
        return function(omega, alpha) {
          var _i;
          for (_i = 0; 0 <= n ? _i < n : _i > n; 0 <= n ? _i++ : _i--) {
            omega = f(omega, alpha);
          }
          return omega;
        };
      }
    })
  });
  addVocabulary({
    'get_⎕': function() {
      if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === 'function') {
        return new APLArray(prompt('⎕:') || '');
      } else {
        return nonceError('Reading from ⎕ is not implemented.');
      }
    },
    'set_⎕': function(x) {
      var s;
      s = format(x).join('\n') + '\n';
      if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === 'function') {
        window.alert(s);
      } else {
        process.stdout.write(s);
      }
      return x;
    },
    'get_⍞': function() {
      if (typeof (typeof window !== "undefined" && window !== null ? window.prompt : void 0) === 'function') {
        return prompt('') || '';
      } else {
        return nonceError('Reading from ⍞ is not implemented.');
      }
    },
    'set_⍞': function(x) {
      var s;
      s = format(x).join('\n');
      if (typeof (typeof window !== "undefined" && window !== null ? window.alert : void 0) === 'function') {
        window.alert(s);
      } else {
        process.stdout.write(s);
      }
      return x;
    },
    'get_⎕IO': function() {
      return APLArray.zero;
    },
    'set_⎕IO': function(x) {
      if (match(x, APLArray.zero)) {
        return x;
      } else {
        return domainError('The index origin (⎕IO) is fixed at 0');
      }
    },
    '⎕DL': cps(function(omega, alpha, _, callback) {
      var t0;
      t0 = +(new Date);
      setTimeout((function() {
        return callback(new APLArray([new Date - t0]));
      }), omega.unwrap());
    }),
    '⎕RE': function(omega, alpha) {
      var e, m, r, re, u, x, y, _i, _len;
      x = alpha.toSimpleString();
      y = omega.toSimpleString();
      try {
        re = new RegExp(x);
      } catch (_error) {
        e = _error;
        domainError(e.toString());
      }
      if (m = re.exec(y)) {
        r = [m.index];
        for (_i = 0, _len = m.length; _i < _len; _i++) {
          u = m[_i];
          r.push(new APLArray(u || ''));
        }
        return new APLArray(r);
      } else {
        return APLArray.zilde;
      }
    },
    '⎕UCS': function(omega, alpha) {
      if (alpha != null) {
        nonceError();
      }
      return omega.map(function(x) {
        var tmp154, y, _ref2;
        if ((tmp154 = (x)) === ~~tmp154 && ((0) <= (_ref2 = tmp154) && _ref2 < (0x10000))) {
          return y = String.fromCharCode(x);
        } else if (typeof x === 'string') {
          return y = x.charCodeAt(0);
        } else {
          return domainError();
        }
      });
    }
  });
  addVocabulary({
    '?': function(omega, alpha) {
      if (alpha) {
        return deal(omega, alpha);
      } else {
        return roll(omega);
      }
    }
  });
  roll = pervasive({
    monad: function(omega) {
      var tmp155;
      if (!((tmp155 = omega) === ~~tmp155 && (1) <= tmp155)) {
        domainError();
      }
      return Math.floor(Math.random() * omega);
    }
  });
  deal = function(omega, alpha) {
    var h, i, j, r, tmp156, tmp157, _i, _j, _ref2, _results;
    alpha = alpha.unwrap();
    omega = omega.unwrap();
    if (!(((tmp156 = omega) === ~~tmp156 && (0) <= tmp156) && ((tmp157 = alpha) === ~~tmp157 && ((0) <= (_ref2 = tmp157) && _ref2 < (omega + 1))))) {
      domainError();
    }
    r = (function() {
      _results = [];
      for (var _i = 0; 0 <= omega ? _i < omega : _i > omega; 0 <= omega ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    for (i = _j = 0; _j < alpha; i = _j += 1) {
      j = i + Math.floor(Math.random() * (omega - i));
      h = r[i];
      r[i] = r[j];
      r[j] = h;
    }
    return new APLArray(r.slice(0, alpha));
  };
  addVocabulary({
    '↗': function(omega) {
      return aplError(omega.toString());
    }
  });
  addVocabulary({
    '⍴': function(omega, alpha) {
      var a, data, e, n, t159, t160, t161, t162, t163, t164, t165, t166, tmp158, x, _i, _len;
      if (alpha) {
        if (alpha.shape.length > 1) {
          rankError();
        }
        a = alpha.toArray();
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          x = a[_i];
          if (!((tmp158 = (x)) === ~~tmp158 && (0) <= tmp158)) {
            domainError();
          }
        }
        n = prod(a);
        if (!n) {
          return new APLArray([], a);
        } else if ((a.length >= omega.shape.length) && arrayEquals(omega.shape, a.slice(a.length - omega.shape.length))) {
          return new APLArray(omega.data, a, repeat([0], a.length - omega.shape.length).concat(omega.stride), omega.offset);
        } else {
          data = [];
          try {
            t159 = omega;
            if (!t159.empty()) {
              t161 = t159.data;
              t162 = t159.shape;
              t163 = t159.stride;
              t164 = t162.length - 1;
              t166 = t159.offset;
              t165 = [];
              t160 = t162.length;
              while (--t160 >= 0) {
                t165.push(0);
              }
              while (true) {
                x = t161[t166];
                if (data.length >= n) {
                  throw 'break';
                }
                data.push(x);
                t160 = t164;
                while (t160 >= 0 && t165[t160] + 1 === t162[t160]) {
                  t166 -= t165[t160] * t163[t160];
                  t165[t160--] = 0;
                }
                if (t160 < 0) {
                  break;
                }
                t165[t160]++;
                t166 += t163[t160];
              }
            }
          } catch (_error) {
            e = _error;
            if (e !== 'break') {
              throw e;
            }
          }
          if (data.length) {
            while (2 * data.length < n) {
              data = data.concat(data);
            }
            if (data.length !== n) {
              data = data.concat(data.slice(0, n - data.length));
            }
          } else {
            data = repeat([omega.getPrototype()], n);
          }
          return new APLArray(data, a);
        }
      } else {
        return new APLArray(omega.shape);
      }
    }
  });
  addVocabulary({
    '⌽': rotate = function(omega, alpha, axis) {
      var a, data, indices, n, offset, p, shape, step, stride, tmp167, tmp168, tmp169;
      if (!(typeof axis === 'undefined' || axis instanceof APLArray)) {
        throw Error("\"assert typeof axis is 'undefined' or axis instanceof APLArray\" at src/vocabulary/rotate.coffee:4");
      }
      if (alpha) {
        axis = !axis ? omega.shape.length - 1 : axis.unwrap();
        if (!((tmp167 = (axis)) === ~~tmp167)) {
          domainError();
        }
        if (omega.shape.length && !((0 <= axis && axis < omega.shape.length))) {
          indexError();
        }
        step = alpha.unwrap();
        if (!((tmp168 = (step)) === ~~tmp168)) {
          domainError();
        }
        if (!step) {
          return omega;
        }
        n = omega.shape[axis];
        step = (n + (step % n)) % n;
        if (omega.empty() || step === 0) {
          return omega;
        }
        data = [];
        shape = omega.shape, stride = omega.stride;
        p = omega.offset;
        indices = repeat([0], shape.length);
        while (true) {
          data.push(omega.data[p + ((indices[axis] + step) % shape[axis] - indices[axis]) * stride[axis]]);
          a = shape.length - 1;
          while (a >= 0 && indices[a] + 1 === shape[a]) {
            p -= indices[a] * stride[a];
            indices[a--] = 0;
          }
          if (a < 0) {
            break;
          }
          indices[a]++;
          p += stride[a];
        }
        return new APLArray(data, shape);
      } else {
        if (axis) {
          if (!axis.isSingleton()) {
            lengthError();
          }
          axis = axis.unwrap();
          if (!((tmp169 = (axis)) === ~~tmp169)) {
            domainError();
          }
          if (!((0 <= axis && axis < omega.shape.length))) {
            indexError();
          }
        } else {
          axis = [omega.shape.length - 1];
        }
        if (omega.shape.length === 0) {
          return omega;
        }
        stride = omega.stride.slice(0);
        stride[axis] = -stride[axis];
        offset = omega.offset + (omega.shape[axis] - 1) * omega.stride[axis];
        return new APLArray(omega.data, omega.shape, stride, offset);
      }
    },
    '⊖': function(omega, alpha, axis) {
      if (axis == null) {
        axis = APLArray.zero;
      }
      return rotate(omega, alpha, axis);
    }
  });
  addVocabulary({
    '/': adverb(function(omega, alpha, axis) {
      if (typeof omega === 'function') {
        return reduce(omega, alpha, axis);
      } else {
        return compressOrReplicate(omega, alpha, axis);
      }
    }),
    '⌿': adverb(function(omega, alpha, axis) {
      if (axis == null) {
        axis = APLArray.zero;
      }
      if (typeof omega === 'function') {
        return reduce(omega, alpha, axis);
      } else {
        return compressOrReplicate(omega, alpha, axis);
      }
    })
  });
  reduce = this.reduce = function(f, g, axis0) {
    if (!(typeof f === 'function')) {
      throw Error("\"assert typeof f is 'function'\" at src/vocabulary/slash.coffee:36");
    }
    if (!(typeof g === 'undefined')) {
      throw Error("\"assert typeof g is 'undefined'\" at src/vocabulary/slash.coffee:37");
    }
    if (!((typeof axis0 === 'undefined') || (axis0 instanceof APLArray))) {
      throw Error("\"assert((typeof axis0 is 'undefined') or (axis0 instanceof APLArray))\" at src/vocabulary/slash.coffee:38");
    }
    return function(omega, alpha) {
      var a, axis, data, i, indices, isBackwards, isMonadic, isNWise, n, p, rShape, shape, x, y, z, _i, _j, _ref2;
      if (!omega.shape.length) {
        omega = new APLArray([omega.unwrap()]);
      }
      axis = axis0 != null ? axis0.toInt() : omega.shape.length - 1;
      if (!((0 <= axis && axis < omega.shape.length))) {
        rankError();
      }
      if (alpha) {
        isNWise = true;
        n = alpha.toInt();
        if (n < 0) {
          isBackwards = true;
          n = -n;
        }
      } else {
        n = omega.shape[axis];
        isMonadic = true;
      }
      shape = omega.shape.slice(0);
      shape[axis] = omega.shape[axis] - n + 1;
      rShape = shape;
      if (isNWise) {
        if (shape[axis] === 0) {
          return new APLArray([], rShape);
        }
        if (shape[axis] < 0) {
          lengthError();
        }
      } else {
        rShape = rShape.slice(0);
        rShape.splice(axis, 1);
      }
      if (omega.empty()) {
        if ((z = f.identity) != null) {
          if (!(!z.shape.length)) {
            throw Error("\"assert !⍴⍴ z\" at src/vocabulary/slash.coffee:66");
          }
          return new APLArray(z.data, rShape, repeat([0], rShape.length), z.offset);
        } else {
          domainError();
        }
      }
      data = [];
      indices = repeat([0], shape.length);
      p = omega.offset;
      while (true) {
        if (isBackwards) {
          x = omega.data[p];
          x = x instanceof APLArray ? x : APLArray.scalar(x);
          for (i = _i = 1; _i < n; i = _i += 1) {
            y = omega.data[p + i * omega.stride[axis]];
            y = y instanceof APLArray ? y : APLArray.scalar(y);
            x = f(x, y);
          }
        } else {
          x = omega.data[p + (n - 1) * omega.stride[axis]];
          x = x instanceof APLArray ? x : APLArray.scalar(x);
          for (i = _j = _ref2 = n - 2; _j >= 0; i = _j += -1) {
            y = omega.data[p + i * omega.stride[axis]];
            y = y instanceof APLArray ? y : APLArray.scalar(y);
            x = f(x, y);
          }
        }
        if (!x.shape.length) {
          x = x.unwrap();
        }
        data.push(x);
        a = indices.length - 1;
        while (a >= 0 && indices[a] + 1 === shape[a]) {
          p -= indices[a] * omega.stride[a];
          indices[a--] = 0;
        }
        if (a < 0) {
          break;
        }
        p += omega.stride[a];
        indices[a]++;
      }
      return new APLArray(data, rShape);
    };
  };
  compressOrReplicate = function(omega, alpha, axis) {
    var a, b, data, filler, i, indices, n, p, shape, tmp170, x, _i, _j, _len, _ref2;
    if (!omega.shape.length) {
      omega = new APLArray([omega.unwrap()]);
    }
    axis = axis ? axis.toInt(0, omega.shape.length) : omega.shape.length - 1;
    if (alpha.shape.length > 1) {
      rankError();
    }
    a = alpha.toArray();
    n = omega.shape[axis];
    if (a.length === 1) {
      a = repeat(a, n);
    }
    if (n !== 1 && n !== a.length) {
      lengthError();
    }
    shape = omega.shape.slice(0);
    shape[axis] = 0;
    b = [];
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      x = a[i];
      if (!((tmp170 = (x)) === ~~tmp170)) {
        domainError();
      }
      shape[axis] += Math.abs(x);
      for (_j = 0, _ref2 = Math.abs(x); 0 <= _ref2 ? _j < _ref2 : _j > _ref2; 0 <= _ref2 ? _j++ : _j--) {
        b.push(x > 0 ? i : null);
      }
    }
    if (n === 1) {
      b = (function() {
        var _k, _len1, _results;
        _results = [];
        for (_k = 0, _len1 = b.length; _k < _len1; _k++) {
          x = b[_k];
          _results.push(x != null ? 0 : x);
        }
        return _results;
      })();
    }
    data = [];
    if (shape[axis] !== 0 && !omega.empty()) {
      filler = omega.getPrototype();
      p = omega.offset;
      indices = repeat([0], shape.length);
      while (true) {
        x = b[indices[axis]] != null ? omega.data[p + b[indices[axis]] * omega.stride[axis]] : filler;
        data.push(x);
        i = shape.length - 1;
        while (i >= 0 && indices[i] + 1 === shape[i]) {
          if (i !== axis) {
            p -= omega.stride[i] * indices[i];
          }
          indices[i--] = 0;
        }
        if (i < 0) {
          break;
        }
        if (i !== axis) {
          p += omega.stride[i];
        }
        indices[i]++;
      }
    }
    return new APLArray(data, shape);
  };
  addVocabulary({
    '⌷': squish = function(omega, alpha, axes) {
      var a, axis, h, i, r, tmp171, u, _i, _j, _k, _len, _ref2, _ref3, _results;
      if (typeof omega === 'function') {
        return function(x, y) {
          return omega(x, y, alpha);
        };
      }
      if (!alpha) {
        nonceError();
      }
      if (1 < alpha.shape.length) {
        rankError();
      }
      a = alpha.toArray();
      if (a.length > omega.shape.length) {
        lengthError();
      }
      if (axes) {
        axes = axes.toArray();
        if (a.length !== axes.length) {
          lengthError();
        }
        h = Array(omega.shape.length);
        for (_i = 0, _len = axes.length; _i < _len; _i++) {
          axis = axes[_i];
          if (!((tmp171 = (axis)) === ~~tmp171)) {
            domainError();
          }
          if (!((0 <= axis && axis < omega.shape.length))) {
            rankError();
          }
          if (h[axis]) {
            rankError('Duplicate axis');
          }
          h[axis] = 1;
        }
      } else {
        axes = (function() {
          _results = [];
          for (var _j = 0, _ref2 = a.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; 0 <= _ref2 ? _j++ : _j--){ _results.push(_j); }
          return _results;
        }).apply(this);
      }
      r = omega;
      for (i = _k = _ref3 = a.length - 1; _k >= 0; i = _k += -1) {
        u = a[i] instanceof APLArray ? a[i] : new APLArray([a[i]], []);
        r = indexAtSingleAxis(r, u, axes[i]);
      }
      return r;
    },
    _index: function(alphaAndAxes, omega) {
      var alpha, axes, _ref2;
      _ref2 = alphaAndAxes.toArray(), alpha = _ref2[0], axes = _ref2[1];
      return squish(omega, alpha, axes);
    },
    _substitute: function(args) {
      var a, alpha, axes, data, i, omega, p, stride, subs, t172, t173, t174, t175, t176, t177, t178, t179, t180, t181, t182, t183, t184, u, v, value, x, _i, _j, _len, _ref2, _ref3, _ref4, _results;
      _ref2 = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = args.toArray();
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          x = _ref2[_i];
          if (x instanceof APLArray) {
            _results.push(x);
          } else {
            _results.push(new APLArray([x], []));
          }
        }
        return _results;
      })(), value = _ref2[0], alpha = _ref2[1], omega = _ref2[2], axes = _ref2[3];
      if (1 < alpha.shape.length) {
        rankError();
      }
      a = alpha.toArray();
      if (a.length > omega.shape.length) {
        lengthError();
      }
      if (axes) {
        if (1 < axes.shape.length) {
          rankError();
        }
        axes = axes.toArray();
        if (a.length !== axes.length) {
          lengthError();
        }
      } else {
        axes = (function() {
          _results = [];
          for (var _i = 0, _ref3 = a.length; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; 0 <= _ref3 ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
      }
      subs = squish(vocabulary['⍳'](new APLArray(omega.shape)), alpha, new APLArray(axes));
      if (value.isSingleton()) {
        value = new APLArray([value], subs.shape, repeat([0], subs.shape.length));
      }
      data = omega.toArray();
      stride = strideForShape(omega.shape);
      t172 = subs;
      t177 = t172.data;
      t179 = t172.shape;
      t181 = t172.stride;
      t173 = value;
      t178 = t173.data;
      t180 = t173.shape;
      t182 = t173.stride;
      if (t179.length !== t180.length) {
        rankError();
      }
      t176 = t179.length;
      while (--t176 >= 0) {
        if (t179[t176] !== t180[t176]) {
          lengthError();
        }
      }
      if (!t172.empty()) {
        t183 = t179.length - 1;
        t174 = t172.offset;
        t175 = t173.offset;
        t184 = Array((t176 = t179.length));
        while (--t176 >= 0) {
          t184[t176] = 0;
        }
        while (true) {
          u = t177[t174];
          v = t178[t175];
          if (v instanceof APLArray && !v.shape.length) {
            v = v.unwrap();
          }
          if (u instanceof APLArray) {
            p = 0;
            _ref4 = u.toArray();
            for (i = _j = 0, _len = _ref4.length; _j < _len; i = ++_j) {
              x = _ref4[i];
              p += x * stride[i];
            }
            data[p] = v;
          } else {
            data[u] = v;
          }
          t176 = t183;
          while (t176 >= 0 && t184[t176] + 1 === t179[t176]) {
            t174 -= t184[t176] * t181[t176];
            t175 -= t184[t176] * t182[t176];
            t184[t176--] = 0;
          }
          if (t176 < 0) {
            break;
          }
          t184[t176]++;
          t174 += t181[t176];
          t175 += t182[t176];
        }
      }
      return new APLArray(data, omega.shape);
    }
  });
  indexAtSingleAxis = function(omega, sub, ax) {
    var chunk, d, data, i, isUniform, k, n, offset, shape, shape1, stride, stride1, subStride, t187, t188, t189, t190, t191, t192, t193, t194, tmp185, tmp186, u, x, _i, _j, _k, _l, _len, _len1, _ref2, _ref3;
    if (!(omega instanceof APLArray)) {
      throw Error("\"assert ⍵ instanceof APLArray\" at src/vocabulary/squish.coffee:122");
    }
    if (!(sub instanceof APLArray)) {
      throw Error("\"assert sub instanceof APLArray\" at src/vocabulary/squish.coffee:123");
    }
    if (!((tmp185 = (ax)) === ~~tmp185)) {
      throw Error("\"assert isInt ax\" at src/vocabulary/squish.coffee:124");
    }
    if (!((0 <= ax && ax < omega.shape.length))) {
      throw Error("\"assert 0 <= ax < ⍴⍴ ⍵\" at src/vocabulary/squish.coffee:125");
    }
    u = sub.toArray();
    n = omega.shape[ax];
    for (_i = 0, _len = u.length; _i < _len; _i++) {
      x = u[_i];
      if (!((tmp186 = (x)) === ~~tmp186)) {
        domainError();
      }
      if (!((0 <= x && x < n))) {
        indexError();
      }
    }
    isUniform = false;
    if (u.length >= 2) {
      isUniform = true;
      d = u[1] - u[0];
      for (i = _j = 2, _ref2 = u.length; _j < _ref2; i = _j += 1) {
        if (u[i] - u[i - 1] !== d) {
          isUniform = false;
          break;
        }
      }
    }
    if (isUniform) {
      shape = omega.shape.slice(0);
      shape.splice.apply(shape, [ax, 1].concat(__slice.call(sub.shape)));
      stride = omega.stride.slice(0);
      subStride = strideForShape(sub.shape);
      for (i = _k = 0, _len1 = subStride.length; _k < _len1; i = ++_k) {
        x = subStride[i];
        subStride[i] = x * d * omega.stride[ax];
      }
      stride.splice.apply(stride, [ax, 1].concat(__slice.call(subStride)));
      offset = omega.offset + u[0] * omega.stride[ax];
      return new APLArray(omega.data, shape, stride, offset);
    } else {
      shape1 = omega.shape.slice(0);
      shape1.splice(ax, 1);
      stride1 = omega.stride.slice(0);
      stride1.splice(ax, 1);
      data = [];
      t187 = sub;
      if (!t187.empty()) {
        t189 = t187.data;
        t190 = t187.shape;
        t191 = t187.stride;
        t192 = t190.length - 1;
        t194 = t187.offset;
        t193 = [];
        t188 = t190.length;
        while (--t188 >= 0) {
          t193.push(0);
        }
        while (true) {
          x = t189[t194];
          chunk = new APLArray(omega.data, shape1, stride1, omega.offset + x * omega.stride[ax]);
          data.push.apply(data, chunk.toArray());
          t188 = t192;
          while (t188 >= 0 && t193[t188] + 1 === t190[t188]) {
            t194 -= t193[t188] * t191[t188];
            t193[t188--] = 0;
          }
          if (t188 < 0) {
            break;
          }
          t193[t188]++;
          t194 += t191[t188];
        }
      }
      shape = shape1.slice(0);
      stride = strideForShape(shape);
      shape.splice.apply(shape, [ax, 0].concat(__slice.call(sub.shape)));
      subStride = strideForShape(sub.shape);
      k = prod(shape1);
      for (i = _l = 0, _ref3 = subStride.length; _l < _ref3; i = _l += 1) {
        subStride[i] *= k;
      }
      stride.splice.apply(stride, [ax, 0].concat(__slice.call(subStride)));
      return new APLArray(data, shape, stride);
    }
  };
  addVocabulary({
    '↑': function(omega, alpha) {
      if (alpha) {
        return take(omega, alpha);
      } else {
        return first(omega);
      }
    }
  });
  take = function(omega, alpha) {
    var a, axis, copyIndices, copyShape, data, i, mustCopy, offset, p, q, shape, stride, x, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref2;
    if (alpha.shape.length > 1) {
      rankError();
    }
    if (!omega.shape.length) {
      omega = new APLArray([omega.unwrap()], (!alpha.shape.length ? [1] : repeat([1], alpha.shape[0])));
    }
    a = alpha.toArray();
    if (a.length > omega.shape.length) {
      rankError();
    }
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      x = a[_i];
      if (typeof x !== 'number' || x !== Math.floor(x)) {
        domainError();
      }
    }
    mustCopy = false;
    shape = omega.shape.slice(0);
    for (i = _j = 0, _len1 = a.length; _j < _len1; i = ++_j) {
      x = a[i];
      shape[i] = Math.abs(x);
      if (shape[i] > omega.shape[i]) {
        mustCopy = true;
      }
    }
    if (mustCopy) {
      stride = Array(shape.length);
      stride[stride.length - 1] = 1;
      for (i = _k = _ref2 = stride.length - 2; _k >= 0; i = _k += -1) {
        stride[i] = stride[i + 1] * shape[i + 1];
      }
      data = repeat([omega.getPrototype()], prod(shape));
      copyShape = shape.slice(0);
      p = omega.offset;
      q = 0;
      for (i = _l = 0, _len2 = a.length; _l < _len2; i = ++_l) {
        x = a[i];
        copyShape[i] = Math.min(omega.shape[i], Math.abs(x));
        if (x < 0) {
          if (x < -omega.shape[i]) {
            q -= (x + omega.shape[i]) * stride[i];
          } else {
            p += (x + omega.shape[i]) * omega.stride[i];
          }
        }
      }
      if (prod(copyShape)) {
        copyIndices = repeat([0], copyShape.length);
        while (true) {
          data[q] = omega.data[p];
          axis = copyShape.length - 1;
          while (axis >= 0 && copyIndices[axis] + 1 === copyShape[axis]) {
            p -= copyIndices[axis] * omega.stride[axis];
            q -= copyIndices[axis] * stride[axis];
            copyIndices[axis--] = 0;
          }
          if (axis < 0) {
            break;
          }
          p += omega.stride[axis];
          q += stride[axis];
          copyIndices[axis]++;
        }
      }
      return new APLArray(data, shape, stride);
    } else {
      offset = omega.offset;
      for (i = _m = 0, _len3 = a.length; _m < _len3; i = ++_m) {
        x = a[i];
        if (x < 0) {
          offset += (omega.shape[i] + x) * omega.stride[i];
        }
      }
      return new APLArray(omega.data, shape, omega.stride, offset);
    }
  };
  first = function(omega) {
    var x;
    x = omega.empty() ? omega.getPrototype() : omega.data[omega.offset];
    if (x instanceof APLArray) {
      return x;
    } else {
      return new APLArray([x], []);
    }
  };
  addVocabulary({
    '⍉': function(omega, alpha) {
      var i, n, shape, stride, tmp195, u, x, _i, _j, _len, _len1, _ref2;
      if (alpha) {
        if (alpha.shape.length > 1) {
          rankError();
        }
        if (!alpha.shape.length) {
          alpha = new APLArray([alpha.unwrap()]);
        }
        n = omega.shape.length;
        if (alpha.shape[0] !== n) {
          lengthError();
        }
        shape = [];
        stride = [];
        _ref2 = alpha.toArray();
        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
          x = _ref2[i];
          if (!((tmp195 = (x)) === ~~tmp195 && (0) <= tmp195)) {
            domainError();
          }
          if (x >= n) {
            rankError();
          }
          if (shape[x] != null) {
            shape[x] = Math.min(shape[x], omega.shape[i]);
            stride[x] += omega.stride[i];
          } else {
            shape[x] = omega.shape[i];
            stride[x] = omega.stride[i];
          }
        }
        for (_j = 0, _len1 = shape.length; _j < _len1; _j++) {
          u = shape[_j];
          if (u == null) {
            rankError();
          }
        }
        return new APLArray(omega.data, shape, stride, omega.offset);
      } else {
        return new APLArray(omega.data, omega.shape.slice(0).reverse(), omega.stride.slice(0).reverse(), omega.offset);
      }
    }
  });
  addVocabulary({
    '⍠': conjunction(function(f, g) {
      if (!(typeof f === 'function')) {
        throw Error("\"assert typeof f is 'function'\" at src/vocabulary/variant.coffee:8");
      }
      if (!(typeof g === 'function')) {
        throw Error("\"assert typeof g is 'function'\" at src/vocabulary/variant.coffee:9");
      }
      return function(omega, alpha, axis) {
        return (alpha != null ? f : g)(omega, alpha, axis);
      };
    })
  });
  _ref2 = [1, 2, 3, 4], NOUN = _ref2[0], VERB = _ref2[1], ADVERB = _ref2[2], CONJUNCTION = _ref2[3];
  exec = function(aplCode, opts) {
    var ast, code, env, k, result, v, x, _ref3, _ref4;
    if (opts == null) {
      opts = {};
    }
    ast = parse(aplCode, opts);
    code = compileAST(ast, opts);
    env = [prelude.env[0].slice(0)];
    _ref3 = ast.vars;
    for (k in _ref3) {
      v = _ref3[k];
      env[0][v.slot] = opts.ctx[k];
    }
    result = vm({
      code: code,
      env: env
    });
    _ref4 = ast.vars;
    for (k in _ref4) {
      v = _ref4[k];
      x = opts.ctx[k] = env[0][v.slot];
      if (v.category === ADVERB) {
        x.isAdverb = true;
      }
      if (v.category === CONJUNCTION) {
        x.isConjunction = true;
      }
    }
    return result;
  };
  repr = function(x) {
    var k, v, y, _ref3;
    if (x === null || ((_ref3 = typeof x) === 'string' || _ref3 === 'number' || _ref3 === 'boolean')) {
      return JSON.stringify(x);
    } else if (x instanceof Array) {
      return "[" + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          y = x[_i];
          _results.push(repr(y));
        }
        return _results;
      })()).join(',')) + "]";
    } else if (x.repr) {
      return x.repr();
    } else {
      return "{" + (((function() {
        var _results;
        _results = [];
        for (k in x) {
          v = x[k];
          _results.push("" + (repr(k)) + ":" + (repr(v)));
        }
        return _results;
      })()).join(',')) + "}";
    }
  };
  compileAST = function(ast, opts) {
    var categorizeLambdas, err, i, queue, render, renderLHS, scopeNode, vars, visit, visitLHS, _i, _ref3;
    if (opts == null) {
      opts = {};
    }
    ast.scopeDepth = 0;
    ast.nSlots = prelude.nSlots;
    ast.vars = Object.create(prelude.vars);
    (function() {
      var k, v, varInfo, _ref3, _results;
      if (opts.ctx == null) {
        opts.ctx = Object.create(vocabulary);
      }
      _ref3 = opts.ctx;
      _results = [];
      for (k in _ref3) {
        v = _ref3[k];
        if (!(!ast.vars[k])) {
          continue;
        }
        ast.vars[k] = varInfo = {
          category: NOUN,
          slot: ast.nSlots++,
          scopeDepth: ast.scopeDepth
        };
        if (typeof v === 'function' || v instanceof λ) {
          varInfo.category = v.isAdverb ? ADVERB : v.isConjunction ? CONJUNCTION : VERB;
          if (/^[gs]et_.*/.test(k)) {
            _results.push(ast.vars[k.slice(4)] = {
              category: NOUN
            });
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    })();
    err = function(node, message) {
      return syntaxError(message, {
        file: opts.file,
        line: node.startLine,
        col: node.startCol,
        aplCode: opts.aplCode
      });
    };
    if (!((VERB < ADVERB && ADVERB < CONJUNCTION))) {
      throw Error("\"assert VERB < ADVERB < CONJUNCTION # we are relying on this ordering below\" at src/compiler.coffee:36");
    }
    (categorizeLambdas = function(node) {
      var i, r, _i, _ref3;
      switch (node[0]) {
        case 'B':
        case ':':
        case '←':
        case '[':
        case '{':
        case '.':
        case '⍬':
          r = VERB;
          for (i = _i = 1, _ref3 = node.length; _i < _ref3; i = _i += 1) {
            if (node[i]) {
              r = Math.max(r, categorizeLambdas(node[i]));
            }
          }
          if (node[0] === '{') {
            node.category = r;
            return VERB;
          } else {
            return r;
          }
          break;
        case 'S':
        case 'N':
        case 'J':
          return 0;
        case 'X':
          switch (node[1]) {
            case '⍺⍺':
            case '⍶':
            case '∇∇':
              return ADVERB;
            case '⍵⍵':
            case '⍹':
              return CONJUNCTION;
            default:
              return VERB;
          }
          break;
        default:
          if (!(0)) {
            throw Error("\"else assert 0\" at src/compiler.coffee:49");
          }
      }
    })(ast);
    queue = [ast];
    while (queue.length) {
      vars = (scopeNode = queue.shift()).vars;
      visit = function(node) {
        var a, body, d, h, i, j, name, r, v, x, _i, _j, _k, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
        node.scopeNode = scopeNode;
        switch (node[0]) {
          case ':':
            r = visit(node[1]);
            visit(node[2]);
            return r;
          case '←':
            return visitLHS(node[1], visit(node[2]));
          case 'X':
            name = node[1];
            if (((_ref3 = (v = vars["get_" + name])) != null ? _ref3.category : void 0) === VERB) {
              return NOUN;
            } else {
              return ((_ref4 = vars[name]) != null ? _ref4.category : void 0) || valueError("Symbol '" + name + "' is referenced before assignment.", {
                file: opts.file,
                line: node.startLine,
                col: node.startCol,
                aplCode: opts.aplCode
              });
            }
            break;
          case '{':
            for (i = _i = 1, _ref5 = node.length; 1 <= _ref5 ? _i < _ref5 : _i > _ref5; i = 1 <= _ref5 ? ++_i : --_i) {
              queue.push(extend((body = node[i]), {
                scopeNode: scopeNode,
                scopeDepth: d = scopeNode.scopeDepth + 1 + (node.category !== VERB),
                nSlots: 3,
                vars: v = extend(Object.create(vars), {
                  '⍵': {
                    slot: 0,
                    scopeDepth: d,
                    category: NOUN
                  },
                  '∇': {
                    slot: 1,
                    scopeDepth: d,
                    category: VERB
                  },
                  '⍺': {
                    slot: 2,
                    scopeDepth: d,
                    category: NOUN
                  }
                })
              }));
              if (node.category === CONJUNCTION) {
                v['⍵⍵'] = v['⍹'] = {
                  slot: 0,
                  scopeDepth: d - 1,
                  category: VERB
                };
                v['∇∇'] = {
                  slot: 1,
                  scopeDepth: d - 1,
                  category: CONJUNCTION
                };
                v['⍺⍺'] = v['⍶'] = {
                  slot: 2,
                  scopeDepth: d - 1,
                  category: VERB
                };
              } else if (node.category === ADVERB) {
                v['⍺⍺'] = v['⍶'] = {
                  slot: 0,
                  scopeDepth: d - 1,
                  category: VERB
                };
                v['∇∇'] = {
                  slot: 1,
                  scopeDepth: d - 1,
                  category: ADVERB
                };
              }
            }
            return (_ref6 = node.category) != null ? _ref6 : VERB;
          case 'S':
          case 'N':
          case 'J':
          case '⍬':
            return NOUN;
          case '[':
            for (i = _j = 2, _ref7 = node.length; _j < _ref7; i = _j += 1) {
              if (node[i] && visit(node[i]) !== NOUN) {
                err(node, 'Indices must be nouns.');
              }
            }
            return visit(node[1]);
          case '.':
            a = node.slice(1);
            h = Array(a.length);
            for (i = _k = _ref8 = a.length - 1; _k >= 0; i = _k += -1) {
              h[i] = visit(a[i]);
            }
            i = 0;
            while (i < a.length - 1) {
              if ((h[i] === (_ref9 = h[i + 1]) && _ref9 === NOUN)) {
                j = i + 2;
                while (j < a.length && h[j] === NOUN) {
                  j++;
                }
                [].splice.apply(a, [i, j - i].concat(_ref10 = [['V'].concat(a.slice(i, j))])), _ref10;
                [].splice.apply(h, [i, j - i].concat(NOUN)), NOUN;
              } else {
                i++;
              }
            }
            i = a.length - 2;
            while (--i >= 0) {
              if (h[i + 1] === CONJUNCTION && (h[i] !== NOUN || h[i + 2] !== NOUN)) {
                [].splice.apply(a, [i, (i + 3) - i].concat(_ref11 = [['C'].concat(a.slice(i, i + 3))])), _ref11;
                [].splice.apply(h, [i, (i + 3) - i].concat(VERB)), VERB;
                i--;
              }
            }
            i = 0;
            while (i < a.length - 1) {
              if (h[i] !== NOUN && h[i + 1] === ADVERB) {
                [].splice.apply(a, [i, (i + 2) - i].concat(_ref12 = [['A'].concat(a.slice(i, i + 2))])), _ref12;
                [].splice.apply(h, [i, (i + 2) - i].concat(VERB)), VERB;
              } else {
                i++;
              }
            }
            if (h.length === 2 && h[0] !== NOUN && h[1] !== NOUN) {
              a = [['H'].concat(a)];
              h = [VERB];
            }
            if (h.length >= 3 && h.length % 2 === 1 && all((function() {
              var _l, _len, _results;
              _results = [];
              for (_l = 0, _len = h.length; _l < _len; _l++) {
                x = h[_l];
                _results.push(x !== NOUN);
              }
              return _results;
            })())) {
              a = [['F'].concat(a)];
              h = [VERB];
            }
            if (h[h.length - 1] !== NOUN) {
              if (h.length > 1) {
                err(a[h.length - 1], 'Trailing function in expression');
              }
            } else {
              while (h.length > 1) {
                if (h.length === 2 || h[h.length - 3] !== NOUN) {
                  [].splice.apply(a, [-2, 9e9].concat(_ref13 = [['M'].concat(a.slice(-2))])), _ref13;
                  [].splice.apply(h, [-2, 9e9].concat(NOUN)), NOUN;
                } else {
                  [].splice.apply(a, [-3, 9e9].concat(_ref14 = [['D'].concat(a.slice(-3))])), _ref14;
                  [].splice.apply(h, [-3, 9e9].concat(NOUN)), NOUN;
                }
              }
            }
            [].splice.apply(node, [0, 9e9].concat(_ref15 = a[0])), _ref15;
            extend(node, a[0]);
            return h[0];
          default:
            if (!(0)) {
              throw Error("\"assert 0\" at src/compiler.coffee:144");
            }
        }
      };
      visitLHS = function(node, rhsCategory) {
        var c, i, name, _i, _j, _ref3, _ref4;
        node.scopeNode = scopeNode;
        switch (node[0]) {
          case 'X':
            name = node[1];
            if (name === '∇') {
              err(node, 'Assignment to ∇ is not allowed.');
            }
            if (vars[name]) {
              if (vars[name].category !== rhsCategory) {
                err(node, "Inconsistent usage of symbol '" + name + "', it is assigned both nouns and verbs.");
              }
            } else {
              vars[name] = {
                scopeDepth: scopeNode.scopeDepth,
                slot: scopeNode.nSlots++,
                category: rhsCategory
              };
            }
            break;
          case '.':
            rhsCategory === NOUN || err(node, 'Strand assignment can be used only for nouns.');
            for (i = _i = 1, _ref3 = node.length; _i < _ref3; i = _i += 1) {
              visitLHS(node[i], rhsCategory);
            }
            break;
          case '[':
            rhsCategory === NOUN || err(node, 'Index assignment can be used only for nouns.');
            visitLHS(node[1], rhsCategory);
            for (i = _j = 2, _ref4 = node.length; _j < _ref4; i = _j += 1) {
              if (c = node[i]) {
                visit(c);
              }
            }
            break;
          default:
            err(node, "Invalid LHS node type: " + (JSON.stringify(node[0])));
        }
        return rhsCategory;
      };
      for (i = _i = 1, _ref3 = scopeNode.length; _i < _ref3; i = _i += 1) {
        visit(scopeNode[i]);
      }
    }
    render = function(node) {
      var a, axes, c, d, f, fragments, lx, ly, name, r, s, u, v, w, x, y, _j, _k, _ref4, _ref5, _ref6, _ref7;
      switch (node[0]) {
        case 'B':
          if (node.length === 1) {
            return [LDC, APLArray.zilde, RET];
          } else {
            a = [];
            for (i = _j = 1, _ref4 = node.length; _j < _ref4; i = _j += 1) {
              a.push.apply(a, render(node[i]));
              a.push(POP);
            }
            a[a.length - 1] = RET;
            return a;
          }
          break;
        case ':':
          x = render(node[1]);
          y = render(node[2]);
          return x.concat(JEQ, y.length + 2, POP, y, RET);
        case '←':
          return render(node[2]).concat(renderLHS(node[1]));
        case 'X':
          name = node[1];
          vars = node.scopeNode.vars;
          if (((_ref5 = (v = vars["get_" + name])) != null ? _ref5.category : void 0) === VERB) {
            return [LDC, APLArray.zero, GET, v.scopeDepth, v.slot, MON];
          } else {
            v = vars[name];
            return [GET, v.scopeDepth, v.slot];
          }
          break;
        case '{':
          x = render(node[1]);
          lx = [LAM, x.length].concat(x);
          f = (function() {
            switch (node.length) {
              case 2:
                return lx;
              case 3:
                y = render(node[2]);
                ly = [LAM, y.length].concat(y);
                v = node.scopeNode.vars['⍠'];
                return ly.concat(GET, v.scopeDepth, v.slot, lx, DYA);
              default:
                return err(node);
            }
          })();
          if (node.category !== VERB) {
            return [LAM, f.length + 1].concat(f, RET);
          } else {
            return f;
          }
          break;
        case 'S':
          d = node[1][0];
          s = node[1].slice(1, -1).replace(RegExp("" + (d + d), "g"), d);
          return [LDC, new APLArray(s, s.length === 1 ? [] : void 0)];
        case 'N':
          a = (function() {
            var _k, _len, _ref6, _results;
            _ref6 = node[1].replace(/[¯∞]/g, '-').split(/j/i);
            _results = [];
            for (_k = 0, _len = _ref6.length; _k < _len; _k++) {
              x = _ref6[_k];
              if (x === '-') {
                _results.push(Infinity);
              } else if (x === '--') {
                _results.push(-Infinity);
              } else if (x.match(/^-?0x/i)) {
                _results.push(parseInt(x, 16));
              } else {
                _results.push(parseFloat(x));
              }
            }
            return _results;
          })();
          v = a[1] ? new Complex(a[0], a[1]) : a[0];
          return [LDC, new APLArray([v], [])];
        case 'J':
          f = Function("return function(_w,_a){return(" + (node[1].replace(/^«|»$/g, '')) + ")};")();
          return [
            EMB, function(_w, _a) {
              return aplify(f(_w, _a));
            }
          ];
        case '[':
          v = node.scopeNode.vars._index;
          axes = [];
          a = [];
          for (i = _k = 2, _ref6 = node.length; _k < _ref6; i = _k += 1) {
            if (!(c = node[i])) {
              continue;
            }
            axes.push(i - 2);
            a.push.apply(a, render(c));
          }
          a.push(VEC, axes.length, LDC, new APLArray(axes), VEC, 2, GET, v.scopeDepth, v.slot);
          a.push.apply(a, render(node[1]));
          a.push(DYA);
          return a;
        case 'V':
          fragments = (function() {
            var _l, _ref7, _results;
            _results = [];
            for (i = _l = 1, _ref7 = node.length; _l < _ref7; i = _l += 1) {
              _results.push(render(node[i]));
            }
            return _results;
          })();
          if (all((function() {
            var _l, _len, _results;
            _results = [];
            for (_l = 0, _len = fragments.length; _l < _len; _l++) {
              f = fragments[_l];
              _results.push(f.length === 2 && f[0] === LDC);
            }
            return _results;
          })())) {
            return [
              LDC, new APLArray((function() {
                var _l, _len, _results;
                _results = [];
                for (_l = 0, _len = fragments.length; _l < _len; _l++) {
                  f = fragments[_l];
                  _results.push((x = f[1]).isSimple() ? x.unwrap() : x);
                }
                return _results;
              })())
            ];
          } else {
            return (_ref7 = []).concat.apply(_ref7, __slice.call(fragments).concat([VEC], [node.length - 1]));
          }
          break;
        case '⍬':
          return [LDC, APLArray.zilde];
        case 'M':
          return render(node[2]).concat(render(node[1]), MON);
        case 'A':
          return render(node[1]).concat(render(node[2]), MON);
        case 'D':
        case 'C':
          return render(node[3]).concat(render(node[2]), render(node[1]), DYA);
        case 'H':
          v = node.scopeNode.vars._hook;
          return render(node[2]).concat(GET, v.scopeDepth, v.slot, render(node[1]), DYA);
        case 'F':
          u = node.scopeNode.vars._hook;
          v = node.scopeNode.vars._fork1;
          w = node.scopeNode.vars._fork2;
          i = node.length - 1;
          r = render(node[i--]);
          while (i >= 2) {
            r = r.concat(GET, v.scopeDepth, v.slot, render(node[i--]), DYA, GET, w.scopeDepth, w.slot, render(node[i--]), DYA);
          }
          if (i) {
            return r.concat(render(node[1]), GET, u.scopeDepth, u.slot, DYA);
          } else {
            return r;
          }
          break;
        default:
          if (!(0)) {
            throw Error("\"else assert 0\" at src/compiler.coffee:300");
          }
      }
    };
    renderLHS = function(node) {
      var a, axes, c, n, name, v, _j, _k, _ref4, _ref5, _ref6;
      switch (node[0]) {
        case 'X':
          name = node[1];
          vars = node.scopeNode.vars;
          if (((_ref4 = (v = vars["set_" + name])) != null ? _ref4.category : void 0) === VERB) {
            return [GET, v.scopeDepth, v.slot, MON];
          } else {
            v = vars[name];
            return [SET, v.scopeDepth, v.slot];
          }
          break;
        case '.':
          n = node.length - 1;
          a = [SPL, n];
          for (i = _j = 1, _ref5 = node.length; _j < _ref5; i = _j += 1) {
            a.push.apply(a, renderLHS(node[i]));
            a.push(POP);
          }
          return a;
        case '[':
          v = node.scopeNode.vars._substitute;
          axes = [];
          a = [];
          for (i = _k = 2, _ref6 = node.length; _k < _ref6; i = _k += 1) {
            if (!(c = node[i])) {
              continue;
            }
            axes.push(i - 2);
            a.push.apply(a, render(c));
          }
          a.push(VEC, axes.length);
          a.push.apply(a, render(node[1]));
          a.push(LDC, new APLArray(axes), VEC, 4, GET, v.scopeDepth, v.slot, MON);
          a.push.apply(a, renderLHS(node[1]));
          return a;
        default:
          if (!(0)) {
            throw Error("\"assert 0\" at src/compiler.coffee:335");
          }
      }
    };
    return render(ast);
  };
  prelude = (function() {
    var code, env, k, nSlots, v, vars, _ref3;
    _ref3 = {"code":[1,new APLArray([],[0],[1],0),4,0,73,9,7,22,3,1,2,3,0,65,3,1,0,3,0,29,3,1,2,6,3,0,44,5,6,8,3,0,72,3,0,44,6,4,0,44,9,7,39,7,15,3,2,0,3,1,0,5,3,1,2,3,2,2,6,8,3,0,72,7,15,3,2,0,3,1,0,5,3,1,2,3,2,0,6,8,6,8,4,0,74,9,7,173,3,1,2,3,0,62,5,3,0,62,5,3,0,16,1,new APLArray([1],[],[],0),6,11,8,9,1,new APLArray("RANK ERROR",[10],[1],0),3,0,61,5,8,9,3,1,0,4,1,3,9,3,1,2,7,123,3,2,0,3,0,62,5,3,0,62,5,3,0,16,1,new APLArray([1],[],[],0),6,11,8,9,1,new APLArray("RANK ERROR",[10],[1],0),3,0,61,5,8,9,3,2,0,3,0,13,5,4,2,0,9,3,1,3,3,0,62,5,3,0,62,5,3,0,15,3,2,0,3,0,62,5,6,11,8,9,1,new APLArray("RANK ERROR",[10],[1],0),3,0,61,5,8,9,3,1,3,3,0,62,5,3,0,19,3,2,0,6,3,0,45,3,0,65,5,5,11,8,9,1,new APLArray("INDEX ERROR",[11],[1],0),3,0,61,5,8,9,3,1,3,3,0,67,3,2,0,6,3,0,75,5,4,1,3,8,3,0,27,5,5,9,3,1,3,8,3,0,72,7,229,3,1,0,3,0,62,5,3,0,62,5,3,0,14,1,new APLArray([0],[],[],0),6,11,9,9,3,1,0,3,0,70,5,8,9,3,1,0,3,0,62,5,3,0,3,3,0,65,5,5,3,0,14,1,new APLArray([0],[],[],0),6,11,5,9,3,1,0,8,9,3,1,0,3,0,62,5,4,1,3,9,3,1,0,3,0,13,5,4,1,0,9,3,1,0,3,0,62,3,0,27,5,5,4,1,4,3,0,79,3,0,27,5,5,3,0,35,3,0,65,5,5,4,1,5,9,3,1,4,3,0,13,3,0,21,1,new APLArray([1],[],[],0),3,0,62,3,1,5,6,6,3,0,36,3,0,26,6,3,0,37,3,0,62,6,3,0,27,5,5,4,1,4,3,0,35,3,0,65,5,5,3,0,70,5,4,1,6,9,3,1,0,7,18,3,2,0,3,0,62,3,2,2,6,3,0,70,3,1,6,6,8,3,0,27,5,3,1,4,6,3,0,76,3,0,65,5,5,3,0,70,5,3,0,62,3,1,6,3,0,13,3,1,3,6,6,8,6,4,0,75,9,7,23,3,1,0,1,new APLArray([0],[],[],0),2,1,1,new APLArray([0],[1],[1],0),2,2,3,0,68,3,0,13,6,3,1,2,6,8,3,0,72,7,38,3,1,0,3,0,62,3,1,0,3,0,79,5,3,1,0,3,0,62,5,3,0,26,1,new APLArray([1],[],[],0),6,3,0,3,3,0,65,5,5,2,2,6,8,6,4,0,76,9,7,4,3,1,0,8,4,0,77,9,7,4,3,1,2,8,3,0,72,7,3,1,new APLArray([],[0],[1],0),8,6,4,0,78,9,7,15,3,1,0,3,0,20,3,1,2,6,3,0,44,5,8,3,0,72,7,21,1,new APLArray([1],[],[],0),3,0,13,3,1,0,3,0,62,5,6,3,0,62,3,0,73,6,8,6,4,0,79,9,7,22,3,1,2,3,0,3,3,0,25,3,0,0,6,3,1,0,3,0,80,5,6,8,3,0,72,7,724,7,28,1,new APLArray([0.5],[],[],0),3,0,5,3,2,0,3,0,0,5,3,0,3,3,0,25,3,0,0,6,3,2,0,6,6,8,4,1,3,9,7,290,1,new APLArray([1],[],[],0),2,1,1,new APLArray([0],[1],[1],0),2,2,3,0,68,3,2,0,3,0,62,5,6,4,2,3,9,3,2,3,3,0,19,1,new APLArray([1],[],[],0),6,11,43,9,3,2,0,7,35,3,3,0,3,0,13,5,3,1,3,5,4,3,3,9,3,3,3,3,0,4,3,3,0,6,3,3,3,3,0,76,5,2,2,8,5,8,9,1,new APLArray([2],[],[],0),3,0,4,3,2,3,6,3,0,35,5,4,2,4,9,3,2,0,3,0,70,3,2,4,3,0,13,3,2,0,3,0,62,5,3,0,70,1,new APLArray([1],[],[],0),6,6,6,4,2,5,9,3,2,0,3,0,26,3,2,4,3,0,13,1,new APLArray([0],[],[],0),6,6,4,2,6,9,3,2,5,3,2,1,5,10,2,4,2,7,9,4,2,8,9,9,3,2,6,3,0,3,3,0,25,3,0,0,6,3,2,7,3,0,71,5,3,0,0,5,6,4,2,9,9,3,2,9,3,0,3,3,0,25,3,0,0,6,3,2,7,6,3,0,1,3,2,6,6,3,2,1,5,10,2,4,2,10,9,4,2,11,9,9,3,2,10,3,0,13,3,2,7,6,3,2,11,3,0,70,3,2,3,3,0,1,5,3,0,13,1,new APLArray([2],[],[],0),3,0,4,3,2,3,6,3,0,34,5,6,6,3,0,76,3,2,9,3,0,13,3,2,8,6,6,2,2,8,4,1,4,9,7,214,3,2,0,3,0,62,5,3,0,70,1,new APLArray([1],[],[],0),6,4,2,3,3,0,14,1,new APLArray([1],[],[],0),6,11,9,9,3,2,0,3,0,4,5,8,9,1,new APLArray([2],[],[],0),3,0,4,3,2,3,6,3,0,35,5,4,2,4,9,3,2,0,3,0,70,3,2,4,3,0,13,3,2,4,6,6,3,2,1,5,4,2,5,9,3,2,0,3,0,26,3,2,4,3,0,13,3,2,4,6,6,3,2,1,5,4,2,6,9,3,2,0,3,0,70,3,2,3,3,0,1,3,2,4,6,3,0,13,3,2,4,6,6,4,2,7,9,3,2,6,3,0,3,3,0,25,3,0,0,6,3,2,7,6,3,0,3,3,0,25,3,0,0,6,3,2,5,6,3,0,1,5,4,2,8,9,3,2,6,3,0,70,3,2,3,3,0,1,5,3,0,13,1,new APLArray([2],[],[],0),3,0,4,3,2,3,6,3,0,34,5,6,6,3,0,76,3,2,8,3,0,13,3,2,5,6,6,8,4,1,5,9,3,1,0,3,0,62,5,3,0,62,5,3,0,14,1,new APLArray([0],[],[],0),6,11,9,9,3,1,0,3,0,4,5,8,9,3,1,0,3,0,62,5,3,0,62,5,3,0,14,1,new APLArray([1],[],[],0),6,11,17,9,3,1,0,3,0,76,5,3,1,1,5,3,0,13,5,8,9,3,1,0,3,0,62,5,3,0,62,5,3,0,15,1,new APLArray([2],[],[],0),6,11,8,9,1,new APLArray("RANK ERROR",[10],[1],0),3,0,61,5,8,9,3,1,0,3,0,62,5,3,0,19,3,0,65,5,5,3,0,29,1,new APLArray([0],[],[],0),6,11,8,9,1,new APLArray("LENGTH ERROR",[12],[1],0),3,0,61,5,8,9,3,1,0,3,1,4,5,10,2,4,1,6,9,4,1,7,9,9,3,1,6,3,0,71,5,3,0,0,5,3,0,3,3,0,25,3,0,0,6,3,1,7,3,1,5,5,6,8,6,4,0,80,9,7,31,7,11,3,2,2,3,1,0,3,2,0,6,8,3,0,72,7,11,3,2,0,3,1,0,3,2,0,6,8,6,8,4,0,81,8],"nSlots":82,"vars":{"+":{"category":2,"slot":0,"scopeDepth":0},"-":{"category":2,"slot":1,"scopeDepth":0},"−":{"category":2,"slot":2,"scopeDepth":0},"×":{"category":2,"slot":3,"scopeDepth":0},"÷":{"category":2,"slot":4,"scopeDepth":0},"*":{"category":2,"slot":5,"scopeDepth":0},"⋆":{"category":2,"slot":6,"scopeDepth":0},"⍟":{"category":2,"slot":7,"scopeDepth":0},"|":{"category":2,"slot":8,"scopeDepth":0},"∣":{"category":2,"slot":9,"scopeDepth":0},"\\":{"category":3,"slot":10,"scopeDepth":0},"⍀":{"category":3,"slot":11,"scopeDepth":0},"○":{"category":2,"slot":12,"scopeDepth":0},",":{"category":2,"slot":13,"scopeDepth":0},"=":{"category":2,"slot":14,"scopeDepth":0},"≠":{"category":2,"slot":15,"scopeDepth":0},"<":{"category":2,"slot":16,"scopeDepth":0},">":{"category":2,"slot":17,"scopeDepth":0},"≤":{"category":2,"slot":18,"scopeDepth":0},"≥":{"category":2,"slot":19,"scopeDepth":0},"≡":{"category":2,"slot":20,"scopeDepth":0},"∘":{"category":4,"slot":21,"scopeDepth":0},"∪":{"category":2,"slot":22,"scopeDepth":0},"∩":{"category":2,"slot":23,"scopeDepth":0},"⊥":{"category":2,"slot":24,"scopeDepth":0},".":{"category":4,"slot":25,"scopeDepth":0},"↓":{"category":2,"slot":26,"scopeDepth":0},"¨":{"category":3,"slot":27,"scopeDepth":0},"⊤":{"category":2,"slot":28,"scopeDepth":0},"∊":{"category":2,"slot":29,"scopeDepth":0},"∈":{"category":2,"slot":30,"scopeDepth":0},"!":{"category":2,"slot":31,"scopeDepth":0},"⍎":{"category":2,"slot":32,"scopeDepth":0},"⍷":{"category":2,"slot":33,"scopeDepth":0},"⌊":{"category":2,"slot":34,"scopeDepth":0},"⌈":{"category":2,"slot":35,"scopeDepth":0},"_fork1":{"category":2,"slot":36,"scopeDepth":0},"_fork2":{"category":2,"slot":37,"scopeDepth":0},"⍕":{"category":2,"slot":38,"scopeDepth":0},"⍋":{"category":2,"slot":39,"scopeDepth":0},"⍒":{"category":2,"slot":40,"scopeDepth":0},"⍁":{"category":4,"slot":41,"scopeDepth":0},"⍳":{"category":2,"slot":42,"scopeDepth":0},"⊂":{"category":2,"slot":43,"scopeDepth":0},"~":{"category":2,"slot":44,"scopeDepth":0},"∨":{"category":2,"slot":45,"scopeDepth":0},"∧":{"category":2,"slot":46,"scopeDepth":0},"^":{"category":2,"slot":47,"scopeDepth":0},"⍱":{"category":2,"slot":48,"scopeDepth":0},"⍲":{"category":2,"slot":49,"scopeDepth":0},"⍣":{"category":4,"slot":50,"scopeDepth":0},"get_⎕":{"category":2,"slot":51,"scopeDepth":0},"⎕":{"category":1},"set_⎕":{"category":2,"slot":52,"scopeDepth":0},"get_⍞":{"category":2,"slot":53,"scopeDepth":0},"⍞":{"category":1},"set_⍞":{"category":2,"slot":54,"scopeDepth":0},"get_⎕IO":{"category":2,"slot":55,"scopeDepth":0},"⎕IO":{"category":1},"set_⎕IO":{"category":2,"slot":56,"scopeDepth":0},"⎕DL":{"category":2,"slot":57,"scopeDepth":0},"⎕RE":{"category":2,"slot":58,"scopeDepth":0},"⎕UCS":{"category":2,"slot":59,"scopeDepth":0},"?":{"category":2,"slot":60,"scopeDepth":0},"↗":{"category":2,"slot":61,"scopeDepth":0},"⍴":{"category":2,"slot":62,"scopeDepth":0},"⌽":{"category":2,"slot":63,"scopeDepth":0},"⊖":{"category":2,"slot":64,"scopeDepth":0},"/":{"category":3,"slot":65,"scopeDepth":0},"⌿":{"category":3,"slot":66,"scopeDepth":0},"⌷":{"category":2,"slot":67,"scopeDepth":0},"_index":{"category":2,"slot":68,"scopeDepth":0},"_substitute":{"category":2,"slot":69,"scopeDepth":0},"↑":{"category":2,"slot":70,"scopeDepth":0},"⍉":{"category":2,"slot":71,"scopeDepth":0},"⍠":{"category":4,"slot":72,"scopeDepth":0},"⍬":{"scopeDepth":0,"slot":73,"category":1},"_hook":{"scopeDepth":0,"slot":74,"category":4},"⊃":{"scopeDepth":0,"slot":75,"category":2},"⍪":{"scopeDepth":0,"slot":76,"category":2},"⊢":{"scopeDepth":0,"slot":77,"category":2},"⊣":{"scopeDepth":0,"slot":78,"category":2},"≢":{"scopeDepth":0,"slot":79,"category":2},"⌹":{"scopeDepth":0,"slot":80,"category":2},"⍨":{"scopeDepth":0,"slot":81,"category":3}}}, code = _ref3.code, nSlots = _ref3.nSlots, vars = _ref3.vars;
    env = [[]];
    for (k in vars) {
      v = vars[k];
      env[0][v.slot] = vocabulary[k];
    }
    vm({
      code: code,
      env: env
    });
    for (k in vars) {
      v = vars[k];
      vocabulary[k] = env[0][v.slot];
    }
    return {
      nSlots: nSlots,
      vars: vars,
      env: env
    };
  })();
  aplify = function(x) {
    var y;
    if (typeof x === 'string') {
      if (x.length === 1) {
        return APLArray.scalar(x);
      } else {
        return new APLArray(x);
      }
    } else if (typeof x === 'number') {
      return APLArray.scalar(x);
    } else if (x instanceof Array) {
      return new APLArray((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          y = x[_i];
          _results.push((y = aplify(y), y.shape.length ? y : y.unwrap()));
        }
        return _results;
      })());
    } else if (x instanceof APLArray) {
      return x;
    } else {
      return aplError('Cannot aplify object ' + x);
    }
  };

  this.apl = apl = function(aplCode, opts) {
    return (apl.ws(opts))(aplCode);
  };

  extend(apl, {
    format: format,
    approx: approx,
    parse: parse,
    compileAST: compileAST,
    repr: repr
  });

  apl.ws = function(opts) {
    var ctx;
    if (opts == null) {
      opts = {};
    }
    ctx = Object.create(vocabulary);
    if (opts["in"]) {
      ctx['get_⎕'] = ctx['get_⍞'] = function() {
        var s;
        s = opts["in"]();
        if (!(typeof s === 'string')) {
          throw Error("\"if opts.in then ctx['get_⎕'] = ctx['get_⍞'] = -> s = opts.in(); assert typeof s is 'string'; new APLArray s\" at /tmp/apl/src/apl.coffee:61");
        }
        return new APLArray(s);
      };
    }
    if (opts.out) {
      ctx['set_⎕'] = ctx['set_⍞'] = function(x) {
        return opts.out(format(x).join('\n') + '\n');
      };
    }
    return function(aplCode) {
      return exec(aplCode, {
        ctx: ctx
      });
    };
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = apl;
    if (module === (typeof require !== "undefined" && require !== null ? require.main : void 0)) {
      (function() {
        var arg, b, file, k, rl, usage, ws, _i, _len, _ref3;
        usage = 'Usage: apl.js filename.apl\n';
        file = null;
        _ref3 = process.argv.slice(2);
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          arg = _ref3[_i];
          if (arg === '-h' || arg === '--help') {
            process.stderr.write(usage);
            process.exit(0);
          } else if (/^-/.test(arg)) {
            process.stderr.write("unrecognized option: " + arg + "\n" + usage);
            process.exit(1);
          } else if (file != null) {
            process.stderr.write(usage);
            process.exit(1);
          } else {
            file = arg;
          }
        }
        if (file != null) {
          exec(require('fs').readFileSync(file, 'utf8'));
        } else if (!require('tty').isatty()) {
          exec(Buffer.concat((function() {
            var _results;
            _results = [];
            while (true) {
              b = new Buffer(1024);
              if (!(k = require('fs').readSync(0, b, 0, b.length, null))) {
                break;
              }
              _results.push(b.slice(0, k));
            }
            return _results;
          })()).toString('utf8'));
        } else {
          process.stdout.write("ngn apl 2013-12-19\n");
          rl = require('readline').createInterface(process.stdin, process.stdout);
          rl.setPrompt('      ');
          ws = apl.ws();
          rl.on('line', function(line) {
            var e;
            try {
              if (!line.match(/^[\ \t\f\r\n]*$/)) {
                process.stdout.write(format(ws(line)).join('\n') + '\n');
              }
            } catch (_error) {
              e = _error;
              process.stdout.write(e + '\n');
            }
            rl.prompt();
          });
          rl.on('close', function() {
            process.stdout.write('\n');
            return process.exit(0);
          });
          rl.prompt();
        }
      })();
    }
  }

}).call(this);
